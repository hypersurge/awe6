<haxe>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is 
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\HaxeToolkit\haxe\std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of the date. It might
		only have a per-second precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range) where `0` is Sunday.</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="EReg" params="" file="C:\HaxeToolkit\haxe\std/EReg.hx">
		<replace public="1" set="method" line="174">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<new public="1" set="method" line="48">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="List" params="T" file="C:\HaxeToolkit\haxe\std/List.hx">
		<h><c path="_List.ListNode"><c path="List.T"/></c></h>
		<q><c path="_List.ListNode"><c path="List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="52">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="67">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<remove public="1" set="method" line="137">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<new public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="_List.ListNode" params="T" file="C:\HaxeToolkit\haxe\std/List.hx" private="1" module="List">
		<item public="1"><c path="_List.ListNode.T"/></item>
		<next public="1"><c path="_List.ListNode"><c path="_List.ListNode.T"/></c></next>
		<new public="1" set="method" line="255"><f a="item:next">
	<c path="_List.ListNode.T"/>
	<c path="_List.ListNode"><c path="_List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with `NaN` on Windows,
		see <https://bugs.php.net/bug.php?id=42143>]]></haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="267" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="271" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="275" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as `String`, `Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see https://haxe.org/manual/types-nullability.html</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="C:\HaxeToolkit\haxe\std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="C:\HaxeToolkit\haxe\std/StringTools.hx">
		<htmlEscape public="1" set="method" line="153" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<isSpace public="1" set="method" line="245" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="262" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="287" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="309" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<replace public="1" set="method" line="374" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s`. If `by` is also the empty String `""`, `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="396" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="C:\HaxeToolkit\haxe\std/Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline.</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the command line.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f>
			<haxe_doc>Returns all environment variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect `DateTools.format` date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Read the `sys.io.Process` api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting `echo` to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in `sys` sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ValueType" params="" file="C:\HaxeToolkit\haxe\std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<haxe_doc>The different possible runtime types of a value.</haxe_doc>
	</enum>
	<abstract path="XmlType" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx" private="1" module="Xml"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="Xml" params="" file="C:\HaxeToolkit\haxe\std/Xml.hx">
		<Element public="1" set="null" line="68" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" line="72" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" line="76" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" line="80" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" line="84" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" line="88" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" line="92" static="1">
			<x path="XmlType"/>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="97" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="158" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="167" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="176" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="185" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="194" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="203" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="212" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></attributeMap>
		<get public="1" set="method" line="220">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="231">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="253">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="263">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<elements public="1" set="method" line="283">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<firstElement public="1" set="method" line="310">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="326">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="339">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<new set="method" line="370"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="awe6.AAssetManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types">
		<t path="awe6.core.AAssetManager"/>
		<haxe_doc>* This collection is intended to provide:
 * Single dependency for importing all of awe6
 * Single dependency for generating documentaion of awe6
 * Alternative shorthand namespace for awe6 - e.g. no need to reference core or interface packages.</haxe_doc>
	</typedef>
	<typedef path="awe6.AFactory" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.AFactory"/></typedef>
	<typedef path="awe6.APreloader" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.APreloader"/></typedef>
	<typedef path="awe6.ASession" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.ASession"/></typedef>
	<typedef path="awe6.AudioManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.AudioManager"/></typedef>
	<typedef path="awe6.BasicButton" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.BasicButton"/></typedef>
	<typedef path="awe6.Context" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Context"/></typedef>
	<typedef path="awe6.Encrypter" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Encrypter"/></typedef>
	<typedef path="awe6.Entity" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Entity"/></typedef>
	<typedef path="awe6.InputJoypad" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.InputJoypad"/></typedef>
	<typedef path="awe6.InputKeyboard" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.InputKeyboard"/></typedef>
	<typedef path="awe6.InputManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.InputManager"/></typedef>
	<typedef path="awe6.InputMouse" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.InputMouse"/></typedef>
	<typedef path="awe6.Kernel" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Kernel"/></typedef>
	<typedef path="awe6.MessageManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.MessageManager"/></typedef>
	<typedef path="awe6.Overlay" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Overlay"/></typedef>
	<typedef path="awe6.Process" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Process"/></typedef>
	<typedef path="awe6.Profiler" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.Profiler"/></typedef>
	<typedef path="awe6.Scene" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Scene"/></typedef>
	<typedef path="awe6.SceneManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.SceneManager"/></typedef>
	<typedef path="awe6.SceneTransition" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.SceneTransition"/></typedef>
	<typedef path="awe6.TextStyle" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.TextStyle"/></typedef>
	<typedef path="awe6.Tools" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.core.Tools"/></typedef>
	<typedef path="awe6.View" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><t path="awe6.core.View"/></typedef>
	<typedef path="awe6.EAgenda" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EAgenda"/></typedef>
	<typedef path="awe6.EAudioChannel" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EAudioChannel"/></typedef>
	<typedef path="awe6.EJoypadButton" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EJoypadButton"/></typedef>
	<typedef path="awe6.EJoypadTouch" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EJoypadTouch"/></typedef>
	<typedef path="awe6.EKey" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EKey"/></typedef>
	<typedef path="awe6.EMessage" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EMessage"/></typedef>
	<typedef path="awe6.EMouseButton" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EMouseButton"/></typedef>
	<typedef path="awe6.EMouseCursor" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EMouseCursor"/></typedef>
	<typedef path="awe6.EOverlayButton" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EOverlayButton"/></typedef>
	<typedef path="awe6.EScene" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.EScene"/></typedef>
	<typedef path="awe6.ETextAlign" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.ETextAlign"/></typedef>
	<typedef path="awe6.ETextStyle" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><e path="awe6.interfaces.ETextStyle"/></typedef>
	<typedef path="awe6.IAgendaManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAgendaManager"/></typedef>
	<typedef path="awe6.IAssetManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAssetManager"/></typedef>
	<typedef path="awe6.IAssetManagerProcess" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAssetManagerProcess"/></typedef>
	<typedef path="awe6.IAudioManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IAudioManager"/></typedef>
	<typedef path="awe6.IDisposable" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IDisposable"/></typedef>
	<typedef path="awe6.IEncrypter" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IEncrypter"/></typedef>
	<typedef path="awe6.IEntity" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IEntity"/></typedef>
	<typedef path="awe6.IEntityCollection" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IEntityCollection"/></typedef>
	<typedef path="awe6.IFactory" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IFactory"/></typedef>
	<typedef path="awe6.IInputJoypad" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputJoypad"/></typedef>
	<typedef path="awe6.IInputKeyboard" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputKeyboard"/></typedef>
	<typedef path="awe6.IInputManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputManager"/></typedef>
	<typedef path="awe6.IInputMouse" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IInputMouse"/></typedef>
	<typedef path="awe6.IKernel" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IKernel"/></typedef>
	<typedef path="awe6.ILogger" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ILogger"/></typedef>
	<typedef path="awe6.IMessageManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IMessageManager"/></typedef>
	<typedef path="awe6.IOverlay" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IOverlay"/></typedef>
	<typedef path="awe6.IOverlayProcess" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IOverlayProcess"/></typedef>
	<typedef path="awe6.IPauseable" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPauseable"/></typedef>
	<typedef path="awe6.IPositionable" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPositionable"/></typedef>
	<typedef path="awe6.IPreloader" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPreloader"/></typedef>
	<typedef path="awe6.IPriority" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IPriority"/></typedef>
	<typedef path="awe6.IProcess" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IProcess"/></typedef>
	<typedef path="awe6.IProgress" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IProgress"/></typedef>
	<typedef path="awe6.IResettable" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IResettable"/></typedef>
	<typedef path="awe6.IScene" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IScene"/></typedef>
	<typedef path="awe6.ISceneManager" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ISceneManager"/></typedef>
	<typedef path="awe6.ISceneTransition" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ISceneTransition"/></typedef>
	<typedef path="awe6.ISession" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ISession"/></typedef>
	<typedef path="awe6.ITextStyle" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ITextStyle"/></typedef>
	<typedef path="awe6.ITools" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.ITools"/></typedef>
	<typedef path="awe6.IUpdateable" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IUpdateable"/></typedef>
	<typedef path="awe6.IView" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IView"/></typedef>
	<typedef path="awe6.IViewable" params="" file="../../lib/awe6/Types.hx" module="awe6.Types"><c path="awe6.interfaces.IViewable"/></typedef>
	<class path="awe6.Types" params="" file="../../lib/awe6/Types.hx">
		<new set="method" line="116"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Adding a class here improves some editors' shortcut keys.  It has no other purpose, hence being private.</haxe_doc>
	</class>
	<typedef path="awe6.core.AAssetManager" params="" file="../../lib/awe6/core/AAssetManager.hx">
		<c path="awe6.core.drivers.AAssetManager"/>
		<haxe_doc><![CDATA[* The AAssetManager class provides a minimalist abstract implementation of the IAssetManager interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>AAssetManager includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<typedef path="awe6.core.AFactory" params="" file="../../lib/awe6/core/AFactory.hx">
		<c path="awe6.core.drivers.AFactory"/>
		<haxe_doc><![CDATA[* The AFactory class provides a minimalist abstract implementation of the IFactory interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>AFactory includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<typedef path="awe6.core.APreloader" params="" file="../../lib/awe6/core/APreloader.hx">
		<c path="awe6.core.drivers.APreloader"/>
		<haxe_doc><![CDATA[* The APreloader class provides a minimalist abstract implementation of the IPreloader interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>APreloader includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<typedef path="awe6.core.ASession" params="" file="../../lib/awe6/core/ASession.hx">
		<c path="awe6.core.drivers.ASession"/>
		<haxe_doc><![CDATA[* The ASession class provides a minimalist abstract implementation of the ISession interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>ASession includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<typedef path="awe6.core.AudioManager" params="" file="../../lib/awe6/core/AudioManager.hx">
		<c path="awe6.core.drivers.AAudioManager"/>
		<haxe_doc><![CDATA[* The AudioManager class provides a minimalist implementation of the IAudioManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>AudioManager includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.IPauseable" params="" file="../../lib/awe6/interfaces/IPauseable.hx" interface="1">
		<set_isActive public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_isActive>
		<isActive public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Determines if the object is updating or not.</haxe_doc>
		</isActive>
		<pause public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets isActive to false.</haxe_doc>
		</pause>
		<resume public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets isActive to true.</haxe_doc>
		</resume>
		<haxe_doc>* The IPauseable interface should be implemented by objects intended to be temporarily disabled from the broad phase update traversal.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IDisposable" params="" file="../../lib/awe6/interfaces/IDisposable.hx" interface="1">
		<isDisposed public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Returns true if the object has been disposed (or is being disposed).</haxe_doc>
		</isDisposed>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes this object by deallocating all used resources and breaking all
	 * (non-weak) references to other objects. This method must be the final
	 * call in the object's life cycle. No methods except this method should be
	 * called on the object and no properties of the object should be read or
	 * written after a call to this object; otherwise the behaviour is
	 * unreliable. The object may call the method on itself, directly or
	 * indirectly.</haxe_doc>
		</dispose>
		<haxe_doc><![CDATA[* The IDisposable interface should be implemented by objects that require
 * specialised garbage collection or memory deallocation.
 * <p>Once an object is disposed it should be automatically removed from parent heirachies.</p>
 * @author Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IUpdateable" params="" file="../../lib/awe6/interfaces/IUpdateable.hx" interface="1">
		<getAge public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The age of the object.
	 * @param	?asTime	If true treats the time as milliseconds, otherwise as frame updates.
	 * @return	The age of the object (as elapsed time, not time since birth).</haxe_doc>
		</getAge>
		<update public="1" set="method">
			<f a="?deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Used to modify the internal state according to object specific logic and the elapsed time.
	 * <p>This method is called internally by the framework, it will rarely need to be called directly.</p>
	 * @param	?deltaTime	The time elapsed between this update and the previous update.  Can be used to accurately influence rate of change - e.g. speed.]]></haxe_doc>
		</update>
		<haxe_doc>* The IUpdatable interface should be implemented by any object wishing to enter the broad phase update traversal stack.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IProcess" params="" file="../../lib/awe6/interfaces/IProcess.hx" interface="1">
		<extends path="awe6.interfaces.IPauseable"/>
		<extends path="awe6.interfaces.IDisposable"/>
		<extends path="awe6.interfaces.IUpdateable"/>
		<haxe_doc><![CDATA[* The IProcess represents the smallest atom of the awe6 framework.
 * <p>Many managers will implement this interface.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.Process" params="" file="../../lib/awe6/core/Process.hx">
		<implements path="awe6.interfaces.IProcess"/>
		<isActive public="1" set="accessor"><x path="Bool"/></isActive>
		<isDisposed public="1" set="null"><x path="Bool"/></isDisposed>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_tools><c path="awe6.core.Tools"/></_tools>
		<_age><x path="Int"/></_age>
		<_updates><x path="Int"/></_updates>
		<_isEntity><x path="Bool"/></_isEntity>
		<_isIsActiveSetterBypassed><x path="Bool"/></_isIsActiveSetterBypassed>
		<_init set="method" line="61"><f a=""><x path="Void"/></f></_init>
		<dispose public="1" get="inline" set="null" line="70"><f a=""><x path="Void"/></f></dispose>
		<_disposer set="method" line="84"><f a=""><x path="Void"/></f></_disposer>
		<getAge public="1" set="method" line="89"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getAge>
		<update public="1" get="inline" set="null" line="94"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<_updater set="method" line="108"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<set_isActive set="method" line="113"><f a="p_value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isActive>
		<pause public="1" get="inline" set="null" line="135"><f a=""><x path="Void"/></f></pause>
		<_pauser set="method" line="153"><f a=""><x path="Void"/></f></_pauser>
		<resume public="1" get="inline" set="null" line="158"><f a=""><x path="Void"/></f></resume>
		<_resumer set="method" line="176"><f a=""><x path="Void"/></f></_resumer>
		<new public="1" set="method" line="53"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Process class provides a minimalist implementation of the IProcess interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IAgendaManager" params="" file="../../lib/awe6/interfaces/IAgendaManager.hx" interface="1">
		<get_agenda public="1" set="method">
			<f a=""><e path="awe6.interfaces.EAgenda"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_agenda>
		<agenda public="1" get="accessor" set="null">
			<e path="awe6.interfaces.EAgenda"/>
			<haxe_doc>* The object's current agenda.</haxe_doc>
		</agenda>
		<setAgenda public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EAgenda"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Change the object's current agenda.
	 * @param	type	The new agenda.  If none is specified will assign to EAgenda.ALWAYS.
	 * @return	Returns true if the agenda has changed, false otherwise.</haxe_doc>
		</setAgenda>
		<haxe_doc>* Objects intending to provide an Agenda driven state machine should implement this interface.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IEntityCollection" params="" file="../../lib/awe6/interfaces/IEntityCollection.hx" interface="1">
		<extends path="awe6.interfaces.IAgendaManager"/>
		<addEntity public="1" set="method">
			<f a="entity:?agenda:?isAddedToView:?viewPriority">
				<c path="awe6.interfaces.IEntity"/>
				<e path="awe6.interfaces.EAgenda"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="awe6.interfaces.IEntity"/>
			</f>
			<haxe_doc>* Adds an entity to this object's children.
	 * @param	entity	The entity to add.
	 * @param	?agenda	Assigns the entity to a specific agenda.  If none is specified will assign to EAgenda.ALWAYS.
	 * @param	?isAddedToView	If true will add the child entity's view to this object's view.
	 * @param	?viewPriority	Sets the child entity's view stack priority order (higher numbers appear closer to the top of the stack).
	 * @return	Added entity (to allow decoration).  Or null if addition was unsuccessful.</haxe_doc>
		</addEntity>
		<removeEntity public="1" set="method">
			<f a="entity:?agenda:?isRemovedFromView">
				<c path="awe6.interfaces.IEntity"/>
				<e path="awe6.interfaces.EAgenda"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes an entity from this object's children.
	 * @param	entity	The entity to remove.
	 * @param	?agenda	If set then will only remove the specified entity from this agenda, else will remove from all agendas.
	 * @param	?isRemovedFromView	If true the child entity's view will be removed from this object's view.</haxe_doc>
		</removeEntity>
		<getEntities public="1" set="method">
			<f a="?agenda">
				<e path="awe6.interfaces.EAgenda"/>
				<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
			</f>
			<haxe_doc><![CDATA[* Retrieves all child entities.
	 * <p>Consider this a runtime only method, rather than calling it during constructor or initialization phases.</p>
	 * @param	?agenda	Used to filter results to the specified agenda.
	 * @return	Array of matching entities.]]></haxe_doc>
		</getEntities>
		<getEntitiesByClass public="1" params="T" set="method">
			<f a="classType:?agenda:?isBubbleDown:?isBubbleUp:?isBubbleEverywhere">
				<x path="Class"><c path="getEntitiesByClass.T"/></x>
				<e path="awe6.interfaces.EAgenda"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="getEntitiesByClass.T"/></c>
			</f>
			<haxe_doc><![CDATA[* Retrieves all child entities that match type.
	 * <p>Consider this a runtime only method, rather than calling it during constructor or initialization phases.</p>
	 * @param	classType	The type of class to match (can be any class, type or interface).
	 * @param	agenda	Used to filter results to the specified agenda.
	 * @param	?isBubbleDown	Set to true if you want to search this object's children for the requested entity.
	 * @param	?isBubbleUp	Set to true if you want to search this object's parent for the requested entity.
	 * @param	?isBubbleEverywhere	Set to true if you want to search the entire entity traversal stack for the requested entity.
	 * @return	Array of matching entities.]]></haxe_doc>
		</getEntitiesByClass>
		<getEntityById public="1" set="method">
			<f a="id:?agenda:?isBubbleDown:?isBubbleUp:?isBubbleEverywhere">
				<c path="String"/>
				<e path="awe6.interfaces.EAgenda"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="awe6.interfaces.IEntity"/>
			</f>
			<haxe_doc><![CDATA[* Retrieves the child entity with the specified id. 
	 * <p>Consider this a runtime only method, rather than calling it during constructor or initialization phases.</p>
	 * @param	id	The unique identifier of the entity you want to retrieve.
	 * @param	?agenda	Used to filter results to the specified agenda.
	 * @param	?isBubbleDown	Set to true if you want to search this object's children for the requested entity.
	 * @param	?isBubbleUp	Set to true if you want to search this object's parent for the requested entity.
	 * @param	?isBubbleEverywhere	Set to true if you want to search the entire entity traversal stack for the requested entity.
	 * @return	The requested entity or null if no entity with this id was found.]]></haxe_doc>
		</getEntityById>
		<haxe_doc>* The IEntityCollection interface should be implemented by objects which compose multiple entities.
 * @author Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IViewable" params="" file="../../lib/awe6/interfaces/IViewable.hx" interface="1">
		<get_view public="1" set="method">
			<f a=""><c path="awe6.interfaces.IView"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_view>
		<view public="1" get="accessor" set="null">
			<c path="awe6.interfaces.IView"/>
			<haxe_doc>* The view bound to this object.</haxe_doc>
		</view>
		<haxe_doc>* The IVewable interface should be implemented by all objects that compose a view.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IEntity" params="" file="../../lib/awe6/interfaces/IEntity.hx" interface="1">
		<extends path="awe6.interfaces.IEntityCollection"/>
		<extends path="awe6.interfaces.IViewable"/>
		<extends path="awe6.interfaces.IProcess"/>
		<set_id public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_id>
		<get_parent public="1" set="method">
			<f a=""><c path="awe6.interfaces.IEntity"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_parent>
		<id public="1" set="accessor">
			<c path="String"/>
			<haxe_doc><![CDATA[* The unique identifier of this entity.
	 * <p>This value is very useful for retrieving a specific entity.</p>]]></haxe_doc>
		</id>
		<parent public="1" get="accessor" set="null">
			<c path="awe6.interfaces.IEntity"/>
			<haxe_doc><![CDATA[* The parent of this entity
	 * <p>The reference is null if this entity has no parent (for example an entity not in the entity traversal stack).</p>
	 * <p>Consider this a runtime only property, rather than calling it during constructor or initialization phases.</p>]]></haxe_doc>
		</parent>
		<remove public="1" set="method">
			<f a="?isRemovedFromView">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to easily remove this entity from its parent.
	 * @param	?isRemovedFromView	Determines whether this object's view is removed from the view stack at the same time.</haxe_doc>
		</remove>
		<haxe_doc><![CDATA[* The IEntity interface should be implemented by all objects in the entity broad phase traversal stack.
 * <p>The IEntity represents the fundamental awe6 building block and provides sufficient functionality to build most game elements.</p>
 * <p>Project specific entities can be created as custom classes, or by injecting functionality through the IEntity interface.</p>
 * @author Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.Entity" params="" file="../../lib/awe6/core/Entity.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IEntity"/>
		<id public="1" set="accessor"><c path="String"/></id>
		<agenda public="1" get="accessor" set="null"><e path="awe6.interfaces.EAgenda"/></agenda>
		<parent public="1" get="accessor" set="null"><c path="awe6.interfaces.IEntity"/></parent>
		<view public="1" get="accessor" set="null"><c path="awe6.interfaces.IView"/></view>
		<_entityAgendaPairs><c path="haxe.ds.GenericStack"><c path="awe6.core._Entity._HelperEntityAgendaPair"/></c></_entityAgendaPairs>
		<_isAgendaDirty><x path="Bool"/></_isAgendaDirty>
		<_cachedEntities><c path="Array"><c path="awe6.interfaces.IEntity"/></c></_cachedEntities>
		<_init set="method" line="63" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="72" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="90" override="1"><f a=""><x path="Void"/></f></_disposer>
		<addEntity public="1" set="method" line="109"><f a="p_entity:?p_agenda:?p_isAddedToView:?p_viewPriority">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="awe6.interfaces.IEntity"/>
</f></addEntity>
		<removeEntity public="1" set="method" line="153"><f a="p_entity:?p_agenda:?p_isRemovedFromView">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEntity>
		<remove public="1" set="method" line="183"><f a="?p_isRemovedFromView">
	<x path="Bool"/>
	<x path="Void"/>
</f></remove>
		<getEntities public="1" set="method" line="191"><f a="?p_agenda">
	<e path="awe6.interfaces.EAgenda"/>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></getEntities>
		<_getEntities set="method" line="196"><f a="?p_agenda">
	<e path="awe6.interfaces.EAgenda"/>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></_getEntities>
		<getEntitiesByClass public="1" params="T" set="method" line="214"><f a="p_classType:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<x path="Class"><c path="getEntitiesByClass.T"/></x>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><c path="getEntitiesByClass.T"/></c>
</f></getEntitiesByClass>
		<getEntityById public="1" set="method" line="240"><f a="p_id:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="String"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="awe6.interfaces.IEntity"/>
</f></getEntityById>
		<setAgenda public="1" set="method" line="274"><f a="p_type">
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
</f></setAgenda>
		<_setParent set="method" line="305"><f a="p_parent">
	<c path="awe6.interfaces.IEntity"/>
	<x path="Void"/>
</f></_setParent>
		<set_id set="method" line="310"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></set_id>
		<get_agenda set="method" line="316"><f a=""><e path="awe6.interfaces.EAgenda"/></f></get_agenda>
		<get_parent set="method" line="321"><f a=""><c path="awe6.interfaces.IEntity"/></f></get_parent>
		<get_view set="method" line="326"><f a=""><c path="awe6.interfaces.IView"/></f></get_view>
		<new public="1" set="method" line="53"><f a="p_kernel:?p_id:?p_context">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<t path="awe6.core.Context"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Entity class provides a minimalist implementation of the IEntity interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IPositionable" params="" file="../../lib/awe6/interfaces/IPositionable.hx" interface="1">
		<set_x public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_x>
		<set_y public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_y>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The horizontal position.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The vertical position.</haxe_doc>
		</y>
		<setPosition public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets both the horizontal and vertical position;
	 * @param	x	The horizontal position.
	 * @param	y	The vertical position.</haxe_doc>
		</setPosition>
		<haxe_doc>* The IPositionable interface should be implemented by objects intended to have 2D spatial position.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.BasicButton" params="" file="../../lib/awe6/core/BasicButton.hx">
		<extends path="awe6.core.Entity"/>
		<implements path="awe6.interfaces.IPositionable"/>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<width public="1" set="accessor"><x path="Float"/></width>
		<height public="1" set="accessor"><x path="Float"/></height>
		<isOver public="1" set="null"><x path="Bool"/></isOver>
		<onClickCallback public="1"><f a=""><x path="Void"/></f></onClickCallback>
		<onRollOverCallback public="1"><f a=""><x path="Void"/></f></onRollOverCallback>
		<onRollOutCallback public="1"><f a=""><x path="Void"/></f></onRollOutCallback>
		<_stateUp><c path="awe6.core._BasicButton._HelperState"/></_stateUp>
		<_stateOver><c path="awe6.core._BasicButton._HelperState"/></_stateOver>
		<_keyType><e path="awe6.interfaces.EKey"/></_keyType>
		<_init set="method" line="69" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="80" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_isPointInsideRectangle set="method" line="110"><f a="p_pointX:p_pointY:p_rectX:p_rectY:p_rectWidth:p_rectHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></_isPointInsideRectangle>
		<onClick public="1" set="method" line="131"><f a=""><x path="Void"/></f></onClick>
		<onRollOver public="1" set="method" line="141"><f a=""><x path="Void"/></f></onRollOver>
		<onRollOut public="1" set="method" line="151"><f a=""><x path="Void"/></f></onRollOut>
		<setPosition public="1" set="method" line="161"><f a="p_x:p_y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<set_x set="method" line="167"><f a="p_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="177"><f a="p_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_width set="method" line="187"><f a="p_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height set="method" line="193"><f a="p_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<new public="1" set="method" line="54"><f a="p_kernel:p_up:p_over:?p_width:?p_height:?p_x:?p_y:?p_keyType:?p_onClickCallback:?p_onRollOverCallback:?p_onRollOutCallback">
	<c path="awe6.interfaces.IKernel"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<e path="awe6.interfaces.EKey"/>
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core._BasicButton._HelperState" params="" file="../../lib/awe6/core/BasicButton.hx" private="1" module="awe6.core.BasicButton">
		<extends path="awe6.core.Entity"/>
		<new public="1" set="method" line="202"><f a="p_kernel:p_view">
	<c path="awe6.interfaces.IKernel"/>
	<c path="awe6.interfaces.IView"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="awe6.core._BasicButton._HelperEState" params="" file="../../lib/awe6/core/BasicButton.hx" private="1" module="awe6.core.BasicButton">
		<UP/>
		<OVER/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="awe6.core.Context" params="" file="../../lib/awe6/core/Context.hx">
		<c path="Array"><d/></c>
		<haxe_doc><![CDATA[* The Context class is a target specific class that defines a native element - typically a view.
 * It is intended to be the only publicly exposed target specific parameter / member.
 * <p>Context includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.IEncrypter" params="" file="../../lib/awe6/interfaces/IEncrypter.hx" interface="1">
		<encrypt public="1" set="method">
			<f a="value:?secret">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Encrypts bytes
	 * @param	value	The unencrypted data. 
	 * @param	?secret	The secret key to encrypt the data with.  Leave blank to use default secret key.
	 * @return	Encrypted (or obfuscated) version of the original.</haxe_doc>
		</encrypt>
		<decrypt public="1" set="method">
			<f a="value:?secret">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Decrypts bytes.
	 * @param	value	The encrypted data.
	 * @param	?secret	The secret key to encrypt the data with.  Leave blank to use default secret key.
	 * @return	Decrypted (or unobfuscated) version of the encrypted data.</haxe_doc>
		</decrypt>
		<haxe_doc><![CDATA[* The IEncrypter interface should be implemented by objects intending to encrypt or decrypt bytes.
 * <p>Due to decompiling client side applications, encryption should not to be considered secure, merely obfuscated / hidden from plainsite.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.Encrypter" params="" file="../../lib/awe6/core/Encrypter.hx">
		<implements path="awe6.interfaces.IEncrypter"/>
		<_defaultSecret><c path="String"/></_defaultSecret>
		<encrypt public="1" set="method" line="48"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></encrypt>
		<decrypt public="1" set="method" line="54"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></decrypt>
		<_xor set="method" line="65">
			<f a="p_value:p_secret">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc><![CDATA[* XOR favours size over strength.  It is also two-directional for easy testing.
	 * <p>XOR is the default encryption routine used in awe6 because (due to the ease of client side application decompiling) the obfuscation routine is secondary to the secret key concealment.</p>
	 * <p>Tip: haXe offers some interesting approaches towards concealing the key from plainsite.</p>]]></haxe_doc>
		</_xor>
		<new public="1" set="method" line="43"><f a="p_defaultSecret">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Encrypter class provides a minimalist implementation of the IEncrypter interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core._Entity._HelperEntityAgendaPair" params="" file="../../lib/awe6/core/Entity.hx" private="1" module="awe6.core.Entity">
		<entity public="1" set="null"><c path="awe6.interfaces.IEntity"/></entity>
		<agenda public="1" set="null"><e path="awe6.interfaces.EAgenda"/></agenda>
		<isAddedToView public="1"><x path="Bool"/></isAddedToView>
		<new public="1" set="method" line="338"><f a="p_entity:?p_agenda">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IInputJoypad" params="" file="../../lib/awe6/interfaces/IInputJoypad.hx" interface="1">
		<getIsButtonDown public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EJoypadButton"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if a specific joypad button is currently down.
	 * @param	type	The joypad button.
	 * @return	Returns true is the joypad button is currently down, false otherwise.</haxe_doc>
		</getIsButtonDown>
		<getIsButtonPress public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EJoypadButton"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if a specific joypad button was pressed in the current update frame.
	 * <p>A press is defined as a new down - i.e. was up previous frame, and is down this frame.</p>
	 * @param	type	The joypad button.
	 * @return	Returns true is the joypad button was pressed in the current update, false otherwise.]]></haxe_doc>
		</getIsButtonPress>
		<getIsButtonRelease public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EJoypadButton"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if a specific joypad button was released in the current update.
	 * <p>A release is defined as a new up - i.e. was down previous frame, and is up this frame.</p>
	 * @param	type	The joypad button.
	 * @return	Returns true is the joypad button was released in the current update, false otherwise.]]></haxe_doc>
		</getIsButtonRelease>
		<getButtonDownDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EJoypadButton"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine how long a specific joypad button has been down.
	 * @param	type	The joypad button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration down (the time held prior to the most recent release).
	 * @return	Returns the duration the joypad button has been down.</haxe_doc>
		</getButtonDownDuration>
		<getButtonUpDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EJoypadButton"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine how long a specific joypad button has been up.
	 * @param	type	The joypad button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration up (the time unused prior to the most recent press).
	 * @return	Returns the duration the joypad button has been up.</haxe_doc>
		</getButtonUpDuration>
		<haxe_doc><![CDATA[* The IInputJoypad interface should be implemented by an object wishing to be used as a directional pad plus two fire button joypad.
 * <p>A joypad is useful for a simple game input device.  The device is limited to 6 EJoypadButtons to prevent keyboard lock and overly complex game controls.</p>
 * <p>A joypad can be configured to accept bespoke key configurations, or alternative user interface control devices (e.g. mouse or touchpad).</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.InputJoypad" params="" file="../../lib/awe6/core/InputJoypad.hx">
		<implements path="awe6.interfaces.IInputJoypad"/>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_mouse><t path="awe6.core.InputMouse"/></_mouse>
		<_isTouchEnabled><x path="Bool"/></_isTouchEnabled>
		<_keyUp><e path="awe6.interfaces.EKey"/></_keyUp>
		<_keyRight><e path="awe6.interfaces.EKey"/></_keyRight>
		<_keyDown><e path="awe6.interfaces.EKey"/></_keyDown>
		<_keyLeft><e path="awe6.interfaces.EKey"/></_keyLeft>
		<_keyPrimary><e path="awe6.interfaces.EKey"/></_keyPrimary>
		<_keySecondary><e path="awe6.interfaces.EKey"/></_keySecondary>
		<_keyUpAlt><e path="awe6.interfaces.EKey"/></_keyUpAlt>
		<_keyRightAlt><e path="awe6.interfaces.EKey"/></_keyRightAlt>
		<_keyDownAlt><e path="awe6.interfaces.EKey"/></_keyDownAlt>
		<_keyLeftAlt><e path="awe6.interfaces.EKey"/></_keyLeftAlt>
		<_keyPrimaryAlt><e path="awe6.interfaces.EKey"/></_keyPrimaryAlt>
		<_keySecondaryAlt><e path="awe6.interfaces.EKey"/></_keySecondaryAlt>
		<_joypadTouchType><e path="awe6.interfaces.EJoypadTouch"/></_joypadTouchType>
		<_joypadStateCache><t path="awe6.core._InputJoypad._JoypadState"/></_joypadStateCache>
		<toString public="1" set="method" line="83"><f a=""><c path="String"/></f></toString>
		<_checkKeyboard set="method" line="88"><f a="p_type:p_function">
	<e path="awe6.interfaces.EJoypadButton"/>
	<f a="">
		<e path="awe6.interfaces.EKey"/>
		<x path="Bool"/>
	</f>
	<x path="Bool"/>
</f></_checkKeyboard>
		<getIsButtonDown public="1" set="method" line="109"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
</f></getIsButtonDown>
		<getIsButtonPress public="1" set="method" line="114"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
</f></getIsButtonPress>
		<getIsButtonRelease public="1" set="method" line="119"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
</f></getIsButtonRelease>
		<getButtonDownDuration public="1" set="method" line="124"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getButtonDownDuration>
		<getButtonUpDuration public="1" set="method" line="146"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getButtonUpDuration>
		<_getTouchButtonPosition set="method" line="168"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<a>
		<y><x path="Float"/></y>
		<x><x path="Float"/></x>
	</a>
</f></_getTouchButtonPosition>
		<_getClosestTouchButton set="method" line="180"><f a="?p_x:?p_y">
	<x path="Float"/>
	<x path="Float"/>
	<e path="awe6.interfaces.EJoypadButton"/>
</f></_getClosestTouchButton>
		<_getTouchState set="method" line="205"><f a=""><t path="awe6.core._InputJoypad._JoypadState"/></f></_getTouchState>
		<_checkTouchIsDown set="method" line="261"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
</f></_checkTouchIsDown>
		<_checkTouchIsPress set="method" line="274"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
</f></_checkTouchIsPress>
		<_checkTouchIsRelease set="method" line="287"><f a="p_type">
	<e path="awe6.interfaces.EJoypadButton"/>
	<x path="Bool"/>
</f></_checkTouchIsRelease>
		<_assignMouse get="inline" set="null" line="300"><f a=""><x path="Bool"/></f></_assignMouse>
		<new public="1" set="method" line="63"><f a="p_kernel:?p_up:?p_right:?p_down:?p_left:?p_primary:?p_secondary:?p_upAlt:?p_rightAlt:?p_downAlt:?p_leftAlt:?p_primaryAlt:?p_secondaryAlt:?p_joypadTouchType">
	<c path="awe6.interfaces.IKernel"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EJoypadTouch"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The InputJoypad class provides a minimalist implementation of the IInputJoypad interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="awe6.core._InputJoypad._JoypadState" params="" file="../../lib/awe6/core/InputJoypad.hx" private="1" module="awe6.core.InputJoypad"><a>
	<isUp><x path="Bool"/></isUp>
	<isRight><x path="Bool"/></isRight>
	<isPrevUp><x path="Bool"/></isPrevUp>
	<isPrevRight><x path="Bool"/></isPrevRight>
	<isPrevLeft><x path="Bool"/></isPrevLeft>
	<isPrevFire><x path="Bool"/></isPrevFire>
	<isPrevDown><x path="Bool"/></isPrevDown>
	<isLeft><x path="Bool"/></isLeft>
	<isFire><x path="Bool"/></isFire>
	<isDown><x path="Bool"/></isDown>
	<age><x path="Int"/></age>
</a></typedef>
	<typedef path="awe6.core.InputKeyboard" params="" file="../../lib/awe6/core/InputKeyboard.hx">
		<c path="awe6.core.drivers.AInputKeyboard"/>
		<haxe_doc><![CDATA[* The InputKeyboard class provides a minimalist implementation of the IInputKeyboard interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>InputKeyboard includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.IResettable" params="" file="../../lib/awe6/interfaces/IResettable.hx" interface="1">
		<reset public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Call method to return object to it's initial state.
	 * @return	True if reset was successful, false otherwise.</haxe_doc>
		</reset>
		<haxe_doc>* The IResettable interface should be implemented by objects intended to be reset (returned to initial state).
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IInputManager" params="" file="../../lib/awe6/interfaces/IInputManager.hx" interface="1">
		<extends path="awe6.interfaces.IResettable"/>
		<joypad public="1" set="null">
			<c path="awe6.interfaces.IInputJoypad"/>
			<haxe_doc>* The default virtual joypad user input: simple 4 directional controller with 2 fire buttons.  Listens to cursor keys and WASD keys.</haxe_doc>
		</joypad>
		<keyboard public="1" set="null">
			<c path="awe6.interfaces.IInputKeyboard"/>
			<haxe_doc>* The virtual keyboard user input: every key on the keyboard.</haxe_doc>
		</keyboard>
		<mouse public="1" set="null">
			<c path="awe6.interfaces.IInputMouse"/>
			<haxe_doc>* The virtual mouse user input: 3 button mouse and scroll wheel.</haxe_doc>
		</mouse>
		<createJoypad public="1" set="method">
			<f a="?up:?right:?down:?left:?primary:?secondary:?upAlt:?rightAlt:?downAlt:?leftAlt:?primaryAlt:?secondaryAlt:?joypadTouchType">
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EKey"/>
				<e path="awe6.interfaces.EJoypadTouch"/>
				<c path="awe6.interfaces.IInputJoypad"/>
			</f>
			<haxe_doc>* Factory method to create a virtual joypad with custom key controls.
	 * @param	?up	The key for up directional movement.  Defaults to up cursor.
	 * @param	?right	The key for right directional movement.  Defaults to right cursor.
	 * @param	?down	The key for down directional movement.  Defaults to down cursor.
	 * @param	?left	The key for left directional movement.  Defaults to left cursor.
	 * @param	?primary	The key for primary fire.  Defaults to space.
	 * @param	?secondary	The key for secondary fire.  Defaults to Z key.
	 * @param	?upAlt	Optional alternative key for up directional movement.
	 * @param	?rightAlt	Optional alternative key for right directional movement.
	 * @param	?downAlt	Optional alternative key for down directional movement.
	 * @param	?leftAlt	Optional alternative key for left directional movement.
	 * @param	?primaryAlt	Optional alternative key for primary fire.
	 * @param	?secondaryAlt	Optional alternative key for secondary fire.
	 * @param	?joypadTouchType	Optional touch enabled mode (for devices without keys), defaults to IFactory.joypadTouchType
	 * @return	A virtual joypad with custom key controls.</haxe_doc>
		</createJoypad>
		<haxe_doc><![CDATA[* The IInputManager interface should be implemented by an object wishing to provide user input states to the kernel.
 * <p>The state machine represents the configuration of the input devices at any specific update frame.</p>
 * <p>State based input is useful for many types of game mechanics, including: momentum, instant replays and special move combos.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.InputManager" params="" file="../../lib/awe6/core/InputManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IInputManager"/>
		<joypad public="1" set="null"><c path="awe6.interfaces.IInputJoypad"/></joypad>
		<keyboard public="1" set="null"><c path="awe6.interfaces.IInputKeyboard"/></keyboard>
		<mouse public="1" set="null"><c path="awe6.interfaces.IInputMouse"/></mouse>
		<_inputKeyboard><t path="awe6.core.InputKeyboard"/></_inputKeyboard>
		<_inputMouse><t path="awe6.core.InputMouse"/></_inputMouse>
		<_init set="method" line="53" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="61" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="68" override="1"><f a=""><x path="Void"/></f></_disposer>
		<createJoypad public="1" set="method" line="75"><f a="?p_up:?p_right:?p_down:?p_left:?p_primary:?p_secondary:?p_upAlt:?p_rightAlt:?p_downAlt:?p_leftAlt:?p_primaryAlt:?p_secondaryAlt:?p_joypadTouchType">
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EKey"/>
	<e path="awe6.interfaces.EJoypadTouch"/>
	<c path="awe6.interfaces.IInputJoypad"/>
</f></createJoypad>
		<reset public="1" set="method" line="80"><f a=""><x path="Bool"/></f></reset>
		<new public="1" set="method" line="44"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The InputManager class provides a minimalist implementation of the IInputManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="awe6.core.InputMouse" params="" file="../../lib/awe6/core/InputMouse.hx">
		<c path="awe6.core.drivers.AInputMouse"/>
		<haxe_doc><![CDATA[* The InputMouse class provides a minimalist implementation of the IInputMouse interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>InputMouse includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<typedef path="awe6.core.Kernel" params="" file="../../lib/awe6/core/Kernel.hx">
		<c path="awe6.core.drivers.AKernel"/>
		<haxe_doc><![CDATA[* The Kernel class provides a minimalist implementation of the IKernel interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>Kernel includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.IMessageManager" params="" file="../../lib/awe6/interfaces/IMessageManager.hx" interface="1">
		<extends path="awe6.interfaces.IResettable"/>
		<addSubscriber public="1" params="M" set="method">
			<f a="subscriber:message:handler:?sender:?senderClassType:?isRemovedAfterFirstSend">
				<c path="awe6.interfaces.IEntity"/>
				<c path="addSubscriber.M"/>
				<f a=":">
					<c path="addSubscriber.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<x path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Register an entity's interest in a subject.
	 * @param	subscriber	Entity listening / observing for messages.
	 * @param	message	Specific message to listen for.
	 * @param	handler	Function to pass observed messages to: receives Message & Sender and returns true if send propogation is to continue (true should be default behavior).
	 * @param	?sender	Only listen to messages from this entity.
	 * @param	?senderClassType	Only listen to messages from this type of entity.
	 * @param	?isRemovedAfterFirstSend	Once a message has been received, no longer listen for further messages under the same criteria.
	 * @type	<M>	Messages can be any type: String, Class, Enum.  For recursive types use Enums.]]></haxe_doc>
		</addSubscriber>
		<getSubscribers public="1" params="M" set="method">
			<f a="?subscriber:?message:?handler:?sender:?senderClassType">
				<c path="awe6.interfaces.IEntity"/>
				<c path="getSubscribers.M"/>
				<f a=":">
					<c path="getSubscribers.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<x path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
				<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
			</f>
			<haxe_doc><![CDATA[* Retrieve all entity's interested in a subject.
	 * <p>All parameters are optional to allow wildcard filtering.</p>
	 * @param	?subscriber	Entity listening / observing for messages.
	 * @param	?message	Specific message to listen for.
	 * @param	?handler	Function to pass observed messages to.
	 * @param	?sender	Only listen to messages from this entity.
	 * @param	?senderClassType	Only listen to messages from this type of entity.
	 * @return	An array of entities corresponding to the specified filters.
	 * @type	<M>	Messages can be any type: String, Class, Enum.  For recursive types use Enums.]]></haxe_doc>
		</getSubscribers>
		<removeSubscribers public="1" params="M" set="method">
			<f a="?subscriber:?message:?handler:?sender:?senderClassType">
				<c path="awe6.interfaces.IEntity"/>
				<c path="removeSubscribers.M"/>
				<f a=":">
					<c path="removeSubscribers.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<x path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Unsubscribes entities matching the specified criteria.
	 * @param	?subscriber	Entity listening / observing for messages.
	 * @param	?message	Specific message to listen for.
	 * @param	?handler	Function to pass observed messages to.
	 * @param	?sender	Only listen to messages from this entity.
	 * @param	?senderClassType	Only listen to messages from this type of entity.
	 * @type	<M>	Messages can be any type: String, Class, Enum.  For recursive types use Enums.]]></haxe_doc>
		</removeSubscribers>
		<sendMessage public="1" params="M" set="method">
			<f a="message:sender:?isBubbleDown:?isBubbleUp:?isBubbleEverywhere">
				<c path="sendMessage.M"/>
				<c path="awe6.interfaces.IEntity"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Dispatch a message from a specific entity.
	 * @param	message	Message to dispatch.
	 * @param	sender	The originator of the message (can be spoofed).
	 * @param	?isBubbleDown	Set to true if you want to dispatch this message to the sender's children.
	 * @param	?isBubbleUp	Set to true if you want to dispatch this message to the sender's parent.
	 * @param	?isBubbleEverywhere	Set to true if you want to dispatch this message to the entity traversal stack.
	 * @type	<M>	Messages can be any type: String, Class, Enum.  For recursive types use Enums.]]></haxe_doc>
		</sendMessage>
		<haxe_doc><![CDATA[* The IMessageManager should be implemented by objects intending to fulfill Entity to Entity synchronous messaging (also known as events or signals).
 * <p>The interface provides an observer pattern oriented manager allowing any Entity to listen to anything on any other Entity.</p>
 * <p>Note, the author is not a fan of observer pattern and provides this manager with a note of caution - there is <i>always</i> a better way to communicate than to fire shots into the dark!</p>
 * <p>This manager is intentionally abstract / generic.  It allows expressive synchronous events - i.e. use anything as a message (string, enumerator, class, state based object etc).</p>
 * <p>It may make more sense to handle events using an alternative, event or signal specific library.  Adapt one as an IEntity and inject into any scene as needed.</p>]]></haxe_doc>
	</class>
	<class path="awe6.core.MessageManager" params="" file="../../lib/awe6/core/MessageManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IMessageManager"/>
		<_subscriptions><c path="haxe.ds.GenericStack"><c path="awe6.core._MessageManager._HelperSubscription"><d/></c></c></_subscriptions>
		<_messageQueue><c path="List"><c path="awe6.core._MessageManager._HelperMessage"><d/></c></c></_messageQueue>
		<_isVerbose><x path="Bool"/></_isVerbose>
		<_init set="method" line="47" override="1"><f a=""><x path="Void"/></f></_init>
		<addSubscriber public="1" params="M" set="method" line="55"><f a="p_subscriber:p_message:p_handler:?p_sender:?p_senderClassType:?p_isRemovedAfterFirstSend">
	<c path="awe6.interfaces.IEntity"/>
	<c path="addSubscriber.M"/>
	<f a=":">
		<c path="addSubscriber.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<x path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
	<x path="Bool"/>
	<x path="Void"/>
</f></addSubscriber>
		<getSubscribers public="1" params="M" set="method" line="61"><f a="?p_subscriber:?p_message:?p_handler:?p_sender:?p_senderClassType">
	<c path="awe6.interfaces.IEntity"/>
	<c path="getSubscribers.M"/>
	<f a=":">
		<c path="getSubscribers.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<x path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></getSubscribers>
		<removeSubscribers public="1" params="M" set="method" line="72"><f a="?p_subscriber:?p_message:?p_handler:?p_sender:?p_senderClassType">
	<c path="awe6.interfaces.IEntity"/>
	<c path="removeSubscribers.M"/>
	<f a=":">
		<c path="removeSubscribers.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<x path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
	<x path="Void"/>
</f></removeSubscribers>
		<sendMessage public="1" params="M" set="method" line="85"><f a="p_message:p_sender:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="sendMessage.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sendMessage>
		<reset public="1" set="method" line="90"><f a=""><x path="Bool"/></f></reset>
		<_updater set="method" line="97" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_isOkToSendMessage set="method" line="110"><f a=""><x path="Bool"/></f></_isOkToSendMessage>
		<_sendMessage params="M" set="method" line="115"><f a="p_message:p_sender:p_target:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="_sendMessage.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_sendMessage>
		<_send params="M" set="method" line="159"><f a="p_subscription:p_message:p_sender">
	<c path="awe6.core._MessageManager._HelperSubscription"><d/></c>
	<c path="_send.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Bool"/>
</f></_send>
		<_getSubscriptions params="M" set="method" line="169">
			<f a="?p_subscriber:?p_message:?p_handler:?p_sender:?p_senderClassType:?p_isRemove">
				<c path="awe6.interfaces.IEntity"/>
				<c path="_getSubscriptions.M"/>
				<f a=":">
					<c path="_getSubscriptions.M"/>
					<c path="awe6.interfaces.IEntity"/>
					<x path="Bool"/>
				</f>
				<c path="awe6.interfaces.IEntity"/>
				<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
				<x path="Bool"/>
				<c path="haxe.ds.GenericStack"><c path="awe6.core._MessageManager._HelperSubscription"><d/></c></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</_getSubscriptions>
		<new public="1" set="method" line="41"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The MessageManager class provides a minimalist implementation of the IMessageManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 * @author	Valerie Elimak]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core._MessageManager._HelperSubscription" params="M" file="../../lib/awe6/core/MessageManager.hx" private="1" module="awe6.core.MessageManager">
		<subscriber public="1" set="null"><c path="awe6.interfaces.IEntity"/></subscriber>
		<message public="1" set="null"><c path="awe6.core._MessageManager._HelperSubscription.M"/></message>
		<messageClass public="1" set="null"><x path="Class"><c path="awe6.core._MessageManager._HelperSubscription.M"/></x></messageClass>
		<handler public="1" set="null"><f a=":">
	<c path="awe6.core._MessageManager._HelperSubscription.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Bool"/>
</f></handler>
		<sender public="1" set="null"><c path="awe6.interfaces.IEntity"/></sender>
		<senderClassType public="1" set="null"><x path="Class"><c path="awe6.interfaces.IEntity"/></x></senderClassType>
		<isRemovedAfterFirstSend public="1" set="null"><x path="Bool"/></isRemovedAfterFirstSend>
		<toString public="1" set="method" line="260"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="249"><f a="p_subscriber:p_message:p_handler:?p_sender:?p_senderClassType:?p_isRemovedAfterFirstSend">
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.core._MessageManager._HelperSubscription.M"/>
	<f a=":">
		<c path="awe6.core._MessageManager._HelperSubscription.M"/>
		<c path="awe6.interfaces.IEntity"/>
		<x path="Bool"/>
	</f>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Class"><c path="awe6.interfaces.IEntity"/></x>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core._MessageManager._HelperMessage" params="M" file="../../lib/awe6/core/MessageManager.hx" private="1" module="awe6.core.MessageManager">
		<message public="1" set="null"><c path="awe6.core._MessageManager._HelperMessage.M"/></message>
		<sender public="1" set="null"><c path="awe6.interfaces.IEntity"/></sender>
		<target public="1" set="null"><c path="awe6.interfaces.IEntity"/></target>
		<isBubbleDown public="1" set="null"><x path="Bool"/></isBubbleDown>
		<isBubbleUp public="1" set="null"><x path="Bool"/></isBubbleUp>
		<isBubbleEverywhere public="1" set="null"><x path="Bool"/></isBubbleEverywhere>
		<new public="1" set="method" line="283"><f a="p_message:p_sender:p_target:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="awe6.core._MessageManager._HelperMessage.M"/>
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.interfaces.IEntity"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="awe6.core.Overlay" params="" file="../../lib/awe6/core/Overlay.hx">
		<c path="awe6.core.drivers.AOverlay"/>
		<haxe_doc><![CDATA[* The Overlay class provides a minimalist implementation of the IOverlay interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>Overlay includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<typedef path="awe6.core.Profiler" params="" file="../../lib/awe6/core/Profiler.hx">
		<c path="awe6.core.drivers.AProfiler"/>
		<haxe_doc><![CDATA[* The Profiler class provides debug information.  Based on net.hires.utils.Stats by Mr.doob & Theo v1.3
 * <p>Profiler includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.IScene" params="" file="../../lib/awe6/interfaces/IScene.hx" interface="1">
		<extends path="awe6.interfaces.IViewable"/>
		<extends path="awe6.interfaces.IEntityCollection"/>
		<extends path="awe6.interfaces.IProcess"/>
		<type public="1" set="null">
			<e path="awe6.interfaces.EScene"/>
			<haxe_doc>* The type of this scene.</haxe_doc>
		</type>
		<isDisposable public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Sets whether the scene is disposed when no longer the active scene.  In most cases this should be true.</haxe_doc>
		</isDisposable>
		<isPauseable public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Sets whether the pause button is displayed / active in the overlay.</haxe_doc>
		</isPauseable>
		<isMuteable public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Sets whether the mute button is displayed / active in the overlay.</haxe_doc>
		</isMuteable>
		<isSessionSavedOnNext public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Sets whether the session is automatically saved when this scene is advanced.  In most cases this should be true.</haxe_doc>
		</isSessionSavedOnNext>
		<haxe_doc><![CDATA[* The IScene interface should be implemented by objects intending to represent scene states in the ISceneManager.
 * <p>Scenes represent the larger building blocks of the awe6 concept, and contain Entities which do the work.</p> 
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.Scene" params="" file="../../lib/awe6/core/Scene.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IScene"/>
		<type public="1" set="null"><e path="awe6.interfaces.EScene"/></type>
		<isDisposable public="1" set="null"><x path="Bool"/></isDisposable>
		<isPauseable public="1" set="null"><x path="Bool"/></isPauseable>
		<isMuteable public="1" set="null"><x path="Bool"/></isMuteable>
		<isSessionSavedOnNext public="1" set="null"><x path="Bool"/></isSessionSavedOnNext>
		<view public="1" get="accessor" set="null"><c path="awe6.interfaces.IView"/></view>
		<agenda public="1" get="accessor" set="null"><e path="awe6.interfaces.EAgenda"/></agenda>
		<_entity set="null"><c path="awe6.interfaces.IEntity"/></_entity>
		<_init set="method" line="65" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="73" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="79" override="1"><f a=""><x path="Void"/></f></_disposer>
		<addEntity public="1" set="method" line="86"><f a="p_entity:?p_agenda:?p_isAddedToView:?p_viewPriority">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="awe6.interfaces.IEntity"/>
</f></addEntity>
		<removeEntity public="1" set="method" line="91"><f a="p_entity:?p_agenda:?p_isRemovedFromView">
	<c path="awe6.interfaces.IEntity"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEntity>
		<getEntities public="1" set="method" line="96"><f a="?p_agenda">
	<e path="awe6.interfaces.EAgenda"/>
	<c path="Array"><c path="awe6.interfaces.IEntity"/></c>
</f></getEntities>
		<getEntitiesByClass public="1" params="T" set="method" line="101"><f a="p_classType:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<x path="Class"><c path="getEntitiesByClass.T"/></x>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><c path="getEntitiesByClass.T"/></c>
</f></getEntitiesByClass>
		<getEntityById public="1" set="method" line="106"><f a="p_id:?p_agenda:?p_isBubbleDown:?p_isBubbleUp:?p_isBubbleEverywhere">
	<c path="String"/>
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="awe6.interfaces.IEntity"/>
</f></getEntityById>
		<get_view set="method" line="111"><f a=""><c path="awe6.interfaces.IView"/></f></get_view>
		<get_agenda set="method" line="116"><f a=""><e path="awe6.interfaces.EAgenda"/></f></get_agenda>
		<setAgenda public="1" set="method" line="121"><f a="p_type">
	<e path="awe6.interfaces.EAgenda"/>
	<x path="Bool"/>
</f></setAgenda>
		<new public="1" set="method" line="56"><f a="p_kernel:p_type:?p_isPauseable:?p_isMuteable:?p_isSessionSavedOnNext">
	<c path="awe6.interfaces.IKernel"/>
	<e path="awe6.interfaces.EScene"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Scene class provides a minimalist implementation of the IScene interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.ISceneManager" params="" file="../../lib/awe6/interfaces/ISceneManager.hx" interface="1">
		<get_scene public="1" set="method">
			<f a=""><c path="awe6.interfaces.IScene"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_scene>
		<scene public="1" get="accessor" set="null">
			<c path="awe6.interfaces.IScene"/>
			<haxe_doc><![CDATA[* The currently active scene.
	 * <p>Use as a runtime property and not as an initialization property.</p>]]></haxe_doc>
		</scene>
		<setScene public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the current scene to a new scene.
	 * @param	type	The new scene.</haxe_doc>
		</setScene>
		<back public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Sets the current scene to the scene returned by IFactory.getBackSceneType().
	 * <p>The new scene should be representative of retreat.</p> 
	 * @see awe6.interfaces.IFactory.getBackSceneType]]></haxe_doc>
		</back>
		<next public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Sets the current scene to the scene returned by IFactory.getNextSceneType().
	 * <p>The new scene should be representative of progress.</p> 
	 * @see awe6.interfaces.IFactory.getNextSceneType]]></haxe_doc>
		</next>
		<restart public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Restarts the current scene.
	 * <p>Equivalent of disposing current scene and then setScene to current scene again.</p>]]></haxe_doc>
		</restart>
		<haxe_doc><![CDATA[* The ISceneManager should be implemented by objects intended to manage the IScene state machine.
 * <p>Only a single scene is active at any given update.  Which scene is configured by this manager.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.SceneManager" params="" file="../../lib/awe6/core/SceneManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.ISceneManager"/>
		<scene public="1" get="accessor" set="null"><c path="awe6.interfaces.IScene"/></scene>
		<view public="1" set="null"><c path="awe6.interfaces.IView"/></view>
		<_sceneTransition><c path="awe6.interfaces.ISceneTransition"/></_sceneTransition>
		<_init set="method" line="56" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="62" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="75" override="1"><f a=""><x path="Void"/></f></_disposer>
		<setScene public="1" set="method" line="89"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<x path="Void"/>
</f></setScene>
		<back public="1" set="method" line="124"><f a=""><x path="Void"/></f></back>
		<next public="1" set="method" line="133"><f a=""><x path="Void"/></f></next>
		<restart public="1" set="method" line="146"><f a=""><x path="Void"/></f></restart>
		<get_scene set="method" line="155"><f a=""><c path="awe6.interfaces.IScene"/></f></get_scene>
		<new public="1" set="method" line="51"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The SceneManager class provides a minimalist implementation of the ISceneManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="awe6.core.SceneTransition" params="" file="../../lib/awe6/core/SceneTransition.hx">
		<c path="awe6.core.drivers.ASceneTransition"/>
		<haxe_doc><![CDATA[* The SceneTransition class provides a minimalist implementation of the ISceneTransition interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>APreloader includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.ITextStyle" params="" file="../../lib/awe6/interfaces/ITextStyle.hx" interface="1">
		<font public="1">
			<c path="String"/>
			<haxe_doc>* The name of the font, as a string.</haxe_doc>
		</font>
		<size public="1">
			<x path="Float"/>
			<haxe_doc>* The point size of text.</haxe_doc>
		</size>
		<color public="1">
			<x path="Int"/>
			<haxe_doc>* The color of the text.</haxe_doc>
		</color>
		<align public="1">
			<e path="awe6.interfaces.ETextAlign"/>
			<haxe_doc>* Font horizontal alignment.</haxe_doc>
		</align>
		<spacingHorizontal public="1">
			<x path="Float"/>
			<haxe_doc>* Space in pixels added between each character.</haxe_doc>
		</spacingHorizontal>
		<spacingVertical public="1">
			<x path="Float"/>
			<haxe_doc>* Space in pixels added between each new line (often called leading).</haxe_doc>
		</spacingVertical>
		<isBold public="1">
			<x path="Bool"/>
			<haxe_doc>* Font weight.</haxe_doc>
		</isBold>
		<isItalic public="1">
			<x path="Bool"/>
			<haxe_doc>* Font emphasis.</haxe_doc>
		</isItalic>
		<thickness public="1">
			<x path="Float"/>
			<haxe_doc>* Thickness of the glyph edges of this font.  Range: -1...1.  Default is 0.</haxe_doc>
		</thickness>
		<filters public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* Collection of visual filters appled to font.</haxe_doc>
		</filters>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* String representation of this object.
	 * @return	Representation of this object.</haxe_doc>
		</toString>
		<clone public="1" set="method">
			<f a=""><c path="awe6.interfaces.ITextStyle"/></f>
			<haxe_doc>* Duplicates this TextStyle.
	 * @return	A duplicate.</haxe_doc>
		</clone>
		<haxe_doc>* The ITextStyle interface should be implemented by objects created by the createTextStyle method of IFactory.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.TextStyle" params="" file="../../lib/awe6/core/TextStyle.hx">
		<implements path="awe6.interfaces.ITextStyle"/>
		<font public="1"><c path="String"/></font>
		<size public="1"><x path="Float"/></size>
		<color public="1"><x path="Int"/></color>
		<align public="1"><e path="awe6.interfaces.ETextAlign"/></align>
		<spacingHorizontal public="1"><x path="Float"/></spacingHorizontal>
		<spacingVertical public="1"><x path="Float"/></spacingVertical>
		<isBold public="1"><x path="Bool"/></isBold>
		<isItalic public="1"><x path="Bool"/></isItalic>
		<thickness public="1"><x path="Float"/></thickness>
		<filters public="1"><c path="Array"><d/></c></filters>
		<toString public="1" set="method" line="66"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="71"><f a=""><c path="awe6.interfaces.ITextStyle"/></f></clone>
		<new public="1" set="method" line="52"><f a="?p_font:?p_size:?p_color:?p_isBold:?p_isItalic:?p_align:?p_spacingHorizontal:?p_spacingVertical:?p_thickness:?p_filters">
	<c path="String"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<e path="awe6.interfaces.ETextAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The TextStyle class provides a minimalist implementation of the ITextStyle interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.ITools" params="" file="../../lib/awe6/interfaces/ITools.hx" interface="1">
		<extends path="awe6.interfaces.IEncrypter"/>
		<BIG_NUMBER public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Used as an arbitrarily high number to avoid infinity and division by zero issues.</haxe_doc>
		</BIG_NUMBER>
		<createGuid public="1" set="method">
			<f a="?isSmall:?prefix">
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Creates a Globally Unique Identifier.
	 * @param	?isSmall	If true returns an 8 bit identifier, 16 bit otherwise.
	 * @param	?prefix	Adds characters to the front of the GUID.
	 * @return	A Globally Unique Identifier.</haxe_doc>
		</createGuid>
		<ease public="1" set="method">
			<f a="originalValue:newValue:ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the tween of two values.
	 * @param	originalValue	Value A.
	 * @param	newValue	Value B.
	 * @param	ease	The proportion of A:B.
	 * @return	The proportional value of A:B.</haxe_doc>
		</ease>
		<sortByString public="1" set="method">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Sorting function for String collections.
	 * @param	a	Value A.
	 * @param	b	Value B.
	 * @return	-1 if A<B, 1 if A>B or 0 if A==B.]]></haxe_doc>
		</sortByString>
		<sortByInt public="1" set="method">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Sorting function for Int collections.
	 * @param	a	Value A.
	 * @param	b	Value B.
	 * @return	-1 if A<B, 1 if A>B or 0 if A==B.]]></haxe_doc>
		</sortByInt>
		<sortByPriority public="1" set="method">
			<f a="a:b">
				<c path="awe6.interfaces.IPriority"/>
				<c path="awe6.interfaces.IPriority"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Sorting function for IPriority collections.
	 * @param	a	Value A.
	 * @param	b	Value B.
	 * @return	-1 if A<B, 1 if A>B or 0 if A==B.]]></haxe_doc>
		</sortByPriority>
		<toUpperCaseFirst public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Creates a copy of a string with the first character uppercased. 
	 * @param	value	The string to transform.
	 * @return	Copy of a string with the first character uppercased.</haxe_doc>
		</toUpperCaseFirst>
		<toCamelCase public="1" set="method">
			<f a="value:?isUpper">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Turns a word or sentence into camelCase.
	 * <p>E.g. "this example string" becomes "thisExampleString".</p>
	 * @param	value	The string to transform.
	 * @param	?isUpper	If true returns PascalCase (first character uppercased).
	 * @return	camelCase or PascalCase representation of a string.]]></haxe_doc>
		</toCamelCase>
		<toConstCase public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Turns a word of sentence into CONST_CASE.
	 * <p>E.g. "this example string" becomes "THIS_EXAMPLE_STRING".</p>
	 * @param	value	The string to transform.
	 * @return	CONST_CASE representation of a string.]]></haxe_doc>
		</toConstCase>
		<fromCamelCase public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Reverts a camelCase string to a word or phrase.
	 * <p>E.g. "thisExampleString" becomes "this example string".</p>
	 * @param	value	The camelCase string to revert.
	 * @return	Word or phrase.]]></haxe_doc>
		</fromCamelCase>
		<fromConstCase public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Reverts a CONST_CASE string to a word or phrase.
	 * <p>E.g. "THIS_EXAMPLE_STRING" becomes "this example string"</p>
	 * @param	value	The CONST_CASE string to revert.
	 * @return	Word or phrase.]]></haxe_doc>
		</fromConstCase>
		<toWords public="1" set="method">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Reverts either a camelCase or CONST_CASE string to a word or phrase.
	 * @param	value	The camelCase or CONST_CASE string.
	 * @return	Word or phrase.</haxe_doc>
		</toWords>
		<limit public="1" set="method">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Clamps a value between a floor and ceiling boundary.
	 * @param	value	The value to clamp.
	 * @param	min	The floor.
	 * @param	max	The ceiling.
	 * @return	Value >= floor and <= ceiling.]]></haxe_doc>
		</limit>
		<range public="1" set="method">
			<f a="value:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Wraps a value between a floor and ceiling boundary.
	 * @param	value	The value to wrap.
	 * @param	min	The floor.
	 * @param	max	The ceiling.
	 * @return	A value between floor and ceiling proportional to over or under shoot.</haxe_doc>
		</range>
		<swap public="1" params="T" set="method">
			<f a="a:b">
				<c path="swap.T"/>
				<c path="swap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Replaces two objects with the content of the other.</haxe_doc>
		</swap>
		<isOdd public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Not divisible by two.
	 * @param	value	The value to check.
	 * @return	True if value not divisible by two.</haxe_doc>
		</isOdd>
		<isEven public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Divisible by two.
	 * @param	value	The value to check.
	 * @return	True if value divisible by two.</haxe_doc>
		</isEven>
		<sgn public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Determine whether a value is less than zero, equal to zero or greater than zero.
	 * @param	value	The value to check.
	 * @return	-1 if <0, 1 if >0, 0 otherwise.]]></haxe_doc>
		</sgn>
		<isBool public="1" set="method">
			<f a="value">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine whether a value is true.
	 * <p>Results vary based on the context of checked value.  Usually safer to do your own Bool checks.</p>
	 * @param	value	The value to check.
	 * @return	True if the value is true.]]></haxe_doc>
		</isBool>
		<nearestSquare public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Calculate the nearest square number to a given value.
	 * <p>Useful for performance routines.</p>
	 * @param	value	The value to check.
	 * @return	A square number nearest to the value.]]></haxe_doc>
		</nearestSquare>
		<distance public="1" set="method">
			<f a="startX:startY:endX:endY:?isSquared">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculates the distance between two coordinates.
	 * @param	startX	The starting position horizontal coordinate.
	 * @param	startY	The starting position vertical coordinate.
	 * @param	endX	The ending position horizontal coordinate.
	 * @param	endY	The ending position vertical coordinate.
	 * @param	isSquared	For performance.  Set this to true square comparator (to avoid sqrt).
	 * @return	The distance between two coordinates.</haxe_doc>
		</distance>
		<convertUpdatesToFormattedTime public="1" set="method">
			<f a="updates:?delimiter">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Creates a string representing a clock in the format "hh'mm'ss".
	 * <p>Uses IFactory.targetFramerate to determine the duration from updates.</p>
	 * @param	updates	The update cycles elapsed in the duration.
	 * @param	?delimiter	The character used to separate the components (default: "'").
	 * @return	String representing a clock in the format "hh:mm:ss".]]></haxe_doc>
		</convertUpdatesToFormattedTime>
		<convertAgeToFormattedTime public="1" set="method">
			<f a="age:?delimiter">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Creates a string representing a clock in the format "hh'mm'ss".
	 * @param	age	The time elapsed in the duration as milliseconds.
	 * @param	?delimiter	The character used to separate the components (default: "'").
	 * @return	String representing a clock in the format "hh:mm:ss".</haxe_doc>
		</convertAgeToFormattedTime>
		<shuffle public="1" params="T" set="method">
			<f a="array">
				<c path="Array"><c path="shuffle.T"/></c>
				<c path="Array"><c path="shuffle.T"/></c>
			</f>
			<haxe_doc>* Randomly sorts an array.</haxe_doc>
		</shuffle>
		<getRandomType public="1" params="T" set="method">
			<f a="e">
				<x path="Enum"><c path="getRandomType.T"/></x>
				<c path="getRandomType.T"/>
			</f>
			<haxe_doc>* Creates any enumerator from the supplied class.</haxe_doc>
		</getRandomType>
		<intToHex public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts an Int to a Hex string.
	 * @param	value	The Int to convert.
	 * @return	Hex value.</haxe_doc>
		</intToHex>
		<serialize public="1" set="method">
			<f a="value">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts an object into a serialized string.
	 * @param	value	The object to convert.
	 * @return	The serialized object.</haxe_doc>
		</serialize>
		<unserialize public="1" set="method">
			<f a="value">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Restores an object from a serialized string.
	 * @param	value	The serialised object.
	 * @return	The object to restore.</haxe_doc>
		</unserialize>
		<haxe_doc><![CDATA[* The ITools interface should be implemented by objects intended to provide tool box functionality.
 * <p>Many of these tools are need in the minimalist implementation of the interfaces.</p>
 * <p>The other functions are often regularly used in entity creation.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.Tools" params="" file="../../lib/awe6/core/Tools.hx">
		<implements path="awe6.interfaces.ITools"/>
		<BIG_NUMBER public="1" set="null"><x path="Int"/></BIG_NUMBER>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_encrypter><c path="awe6.interfaces.IEncrypter"/></_encrypter>
		<createGuid public="1" set="method" line="59"><f a="?p_isSmall:?p_prefix">
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
</f></createGuid>
		<_randomCharacter set="method" line="64"><f a=""><c path="String"/></f></_randomCharacter>
		<ease public="1" get="inline" set="null" line="69"><f a="p_originalValue:p_newValue:p_ease">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<sortByString public="1" get="inline" set="null" line="74"><f a="p_a:p_b">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
</f></sortByString>
		<sortByInt public="1" get="inline" set="null" line="79"><f a="p_a:p_b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></sortByInt>
		<sortByPriority public="1" get="inline" set="null" line="84"><f a="p_a:p_b">
	<c path="awe6.interfaces.IPriority"/>
	<c path="awe6.interfaces.IPriority"/>
	<x path="Int"/>
</f></sortByPriority>
		<toUpperCaseFirst public="1" get="inline" set="null" line="99"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></toUpperCaseFirst>
		<_isCamelCase set="method" line="104"><f a="p_value">
	<c path="String"/>
	<x path="Bool"/>
</f></_isCamelCase>
		<_isConstCase set="method" line="121"><f a="p_value">
	<c path="String"/>
	<x path="Bool"/>
</f></_isConstCase>
		<toCamelCase public="1" set="method" line="134"><f a="p_value:?p_isUpper">
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
</f></toCamelCase>
		<fromCamelCase public="1" set="method" line="164"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></fromCamelCase>
		<toConstCase public="1" set="method" line="185"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></toConstCase>
		<fromConstCase public="1" set="method" line="209"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></fromConstCase>
		<toWords public="1" set="method" line="226"><f a="p_value">
	<c path="String"/>
	<c path="String"/>
</f></toWords>
		<limit public="1" get="inline" set="null" line="239"><f a="p_value:p_min:p_max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></limit>
		<range public="1" get="inline" set="null" line="244"><f a="p_value:p_min:p_max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></range>
		<swap public="1" params="T" get="inline" set="null" line="258"><f a="p_a:p_b">
	<c path="swap.T"/>
	<c path="swap.T"/>
	<x path="Void"/>
</f></swap>
		<getRandomType public="1" params="T" set="method" line="265"><f a="p_enum">
	<x path="Enum"><c path="getRandomType.T"/></x>
	<c path="getRandomType.T"/>
</f></getRandomType>
		<isOdd public="1" get="inline" set="null" line="270"><f a="p_value">
	<x path="Int"/>
	<x path="Bool"/>
</f></isOdd>
		<isEven public="1" get="inline" set="null" line="275"><f a="p_value">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEven>
		<sgn public="1" get="inline" set="null" line="280"><f a="p_value">
	<x path="Float"/>
	<x path="Int"/>
</f></sgn>
		<isBool public="1" get="inline" set="null" line="296"><f a="p_value">
	<d/>
	<x path="Bool"/>
</f></isBool>
		<distance public="1" get="inline" set="null" line="301"><f a="p_startX:p_startY:p_endX:p_endY:?p_isSquared">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></distance>
		<nearestSquare public="1" get="inline" set="null" line="309"><f a="p_value">
	<x path="Float"/>
	<x path="Int"/>
</f></nearestSquare>
		<shuffle public="1" params="T" set="method" line="322"><f a="p_array">
	<c path="Array"><c path="shuffle.T"/></c>
	<c path="Array"><c path="shuffle.T"/></c>
</f></shuffle>
		<convertUpdatesToFormattedTime public="1" set="method" line="337"><f a="p_updates:?p_delimiter">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></convertUpdatesToFormattedTime>
		<convertAgeToFormattedTime public="1" set="method" line="343"><f a="p_age:?p_delimiter">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></convertAgeToFormattedTime>
		<intToHex public="1" get="inline" set="null" line="391"><f a="p_value">
	<x path="Int"/>
	<c path="String"/>
</f></intToHex>
		<serialize public="1" get="inline" set="null" line="398"><f a="p_value">
	<d/>
	<c path="String"/>
</f></serialize>
		<unserialize public="1" get="inline" set="null" line="403"><f a="p_value">
	<c path="String"/>
	<d/>
</f></unserialize>
		<encrypt public="1" set="method" line="408"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></encrypt>
		<decrypt public="1" set="method" line="413"><f a="p_value:?p_secret">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></decrypt>
		<new public="1" set="method" line="52"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Tools class provides a minimalist implementation of the ITools interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="awe6.core.View" params="" file="../../lib/awe6/core/View.hx">
		<c path="awe6.core.drivers.AView"/>
		<haxe_doc><![CDATA[* The View class provides a minimalist implementation of the IView interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * <p>Kernel includes target specific code so is implemented using the awe6.core.drivers package.</p>
 * @author	Robert Fell]]></haxe_doc>
	</typedef>
	<class path="awe6.interfaces.IAssetManager" params="" file="../../lib/awe6/interfaces/IAssetManager.hx" interface="1">
		<getAsset public="1" set="method">
			<f a="id:?packageId:?args">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* Request an embedded or loaded media asset.  E.g. bitmap or sound.
	 * @param	id	The uniqie reference of the requested asset.  E.g. className.
	 * @param	?packageId	The package of the requested asset.  Will default to "assets" if not provided.
	 * @param	?args	Some assets may require additional arguments, provide them here.
	 * @return	The asset - can be of any type for type inference (or cast as appropriate).</haxe_doc>
		</getAsset>
		<haxe_doc><![CDATA[* Provides functions to interact with media assets embedded or loaded in the application.
 * <p>Use with caution, there are usually more type safe ways to utilise assets.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IAssetManagerProcess" params="" file="../../lib/awe6/interfaces/IAssetManagerProcess.hx" interface="1">
		<extends path="awe6.interfaces.IProcess"/>
		<extends path="awe6.interfaces.IAssetManager"/>
		<haxe_doc><![CDATA[* The IAssetManagerProcess interface should be implemented by objects representing an operating IAssetManager.
 * <p>These extra interface requirements are required for internal workings, but are not exposed via the minimal IAssetManager interface.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers.AAssetManager" params="" file="../../lib/awe6/core/drivers/AAssetManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IAssetManagerProcess"/>
		<_PACKAGE_ID get="inline" set="null" line="42" static="1"><c path="String"/></_PACKAGE_ID>
		<_packageId><c path="String"/></_packageId>
		<_init set="method" line="45" override="1"><f a=""><x path="Void"/></f></_init>
		<getAsset public="1" set="method" line="55"><f a="p_id:?p_packageId:?p_args">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></getAsset>
		<_driverGetAsset set="method" line="64"><f a="p_id:?p_packageId:?p_args">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></_driverGetAsset>
		<new public="1" set="method" line="40"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The AAssetManager class provides a minimalist implementation of the IAssetManager interface.
 * <p>It is intended as an abstract class to be extended.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IAudioManager" params="" file="../../lib/awe6/interfaces/IAudioManager.hx" interface="1">
		<set_isMute public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_isMute>
		<isMute public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* If true all audio playback is silenced.</haxe_doc>
		</isMute>
		<start public="1" set="method">
			<f a="id:?audioChannelType:?loops:?startTime:?volume:?pan:?isIgnoredIfPlaying:?onCompleteCallback">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Begin playback of any specified sound.  Optional parameters allow further control.
	 * @param	id	The unique id of the audio media asset.  Can be the className of a loaded asset library.
	 * @param	?audioChannelType	Sounds can be assigned specific channels to allow transformation of groups of related sounds.
	 * @param	?loops	How many times the specified sound should repeat.  Set to -1 for continual loop.
	 * @param	?startTime	Time displacement (ms) from the start of the sound file.
	 * @param	?volume	Adjusts this sound's amplitude relative to the audioChannel.  0...1: 0 is silent, 1 is full.
	 * @param	?pan	Adjusts this sound's stereo effect relative to the audioChannel.  -1...1: -1 is left channel only, 0 is central, 1 is right channel only.
	 * @param	?isIgnoredIfPlaying	If true and this sound is already playing in the specified channel the start request will be skipped.  If false there is a potential for the same sound to play over the top of itself.
	 * @param	?onCompleteCallback	Callback method to execute on sound complete.</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a="?id:?audioChannelType">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* End playback of any specified sound.  To stop all sounds on all channels, leave all parameters blank.
	 * @param	?id	The unique id of the audio media asset intended to be stopped.  If null will stop all sounds on the specific audioChannel.
	 * @param	?audioChannelType	If specified will only stop sounds assigned to this channel.</haxe_doc>
		</stop>
		<transform public="1" set="method">
			<f a="?id:?audioChannelType:?volume:?pan:?asRelative">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjusts the playback of any specified sound.  To adjust all sounds, ommit id and audioChannelType.
	 * @param	?id	The unique id of the audio media asset intended to be transformed.  If null will transform all sounds on the specific audioChannel.
	 * @param	?audioChannelType	If specified will only transform sounds assigned to this channel.
	 * @param	?volume	Adjusts this sound's amplitude relative to the audioChannel.  0...1: 0 is silent, 1 is full.
	 * @param	?pan	Adjusts this sound's stereo effect relative to the audioChannel.  -1...1: -1 is left channel only, 0 is central, 1 is right channel only.
	 * @param	?asRelative	If true will adjust sounds relative to their original transformation.  If false will set them as absolute values.</haxe_doc>
		</transform>
		<isPlaying public="1" set="method">
			<f a="?id:?audioChannelType">
				<c path="String"/>
				<e path="awe6.interfaces.EAudioChannel"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Discover if a specified sound is playing.
	 * @param	?id	The unique id of the audio media asset under investigation.  If null will search entire audioChannel for activity.
	 * @param	?audioChannelType	If specified will only investigate the specified channel.  If ommitted will investigate all channels.
	 * @return	Returns true if a match is found, otherwise false.</haxe_doc>
		</isPlaying>
		<haxe_doc>* Provides functions to control playback of audio: sounds, music etc. 
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.drivers.AAudioManager" params="" file="../../lib/awe6/core/drivers/AAudioManager.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IAudioManager"/>
		<_PACKAGE_ID get="inline" set="null" line="44" static="1"><c path="String"/></_PACKAGE_ID>
		<isMute public="1" set="accessor"><x path="Bool"/></isMute>
		<_sounds><c path="Array"><c path="awe6.core.drivers._AHelperSound"/></c></_sounds>
		<_packageId><c path="String"/></_packageId>
		<_init set="method" line="50" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="66" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="78" override="1"><f a=""><x path="Void"/></f></_disposer>
		<start public="1" set="method" line="88"><f a="p_id:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_isIgnoredIfPlaying:?p_onCompleteCallback">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></start>
		<_driverSoundFactory set="method" line="105"><f a="p_id:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_onCompleteCallback">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<c path="awe6.core.drivers._AHelperSound"/>
</f></_driverSoundFactory>
		<stop public="1" set="method" line="111"><f a="?p_id:?p_audioChannelType">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<x path="Void"/>
</f></stop>
		<transform public="1" set="method" line="120"><f a="?p_id:?p_audioChannelType:?p_volume:?p_pan:?p_asRelative">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></transform>
		<set_isMute set="method" line="129"><f a="p_value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isMute>
		<_driverSetIsMute set="method" line="136"><f a="p_value">
	<x path="Bool"/>
	<x path="Void"/>
</f></_driverSetIsMute>
		<_getSounds set="method" line="141"><f a="?p_id:?p_audioChannelType">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<c path="Array"><c path="awe6.core.drivers._AHelperSound"/></c>
</f></_getSounds>
		<isPlaying public="1" set="method" line="181"><f a="?p_id:?p_audioChannelType">
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<x path="Bool"/>
</f></isPlaying>
		<new public="1" set="method" line="42"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The AudioManager class provides a minimalist implementation of the IAudioManager interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers._AHelperSound" params="" file="../../lib/awe6/core/drivers/AAudioManager.hx" module="awe6.core.drivers.AAudioManager">
		<implements path="awe6.interfaces.IDisposable"/>
		<isDisposed public="1" set="null"><x path="Bool"/></isDisposed>
		<id public="1"><c path="String"/></id>
		<audioChannelType public="1"><e path="awe6.interfaces.EAudioChannel"/></audioChannelType>
		<_packageId><c path="String"/></_packageId>
		<_loops><x path="Int"/></_loops>
		<_startTime><x path="Int"/></_startTime>
		<_volume><x path="Float"/></_volume>
		<_pan><x path="Float"/></_pan>
		<_onCompleteCallback><f a=""><x path="Void"/></f></_onCompleteCallback>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_init set="method" line="223"><f a=""><x path="Void"/></f></_init>
		<_driverInit set="method" line="228"><f a=""><x path="Void"/></f></_driverInit>
		<transform public="1" set="method" line="233"><f a="?p_volume:?p_pan:?p_asRelative">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></transform>
		<_driverTransform set="method" line="252"><f a="?p_asRelative">
	<x path="Bool"/>
	<x path="Void"/>
</f></_driverTransform>
		<stop public="1" set="method" line="257"><f a=""><x path="Void"/></f></stop>
		<_driverStop set="method" line="263"><f a=""><x path="Void"/></f></_driverStop>
		<dispose public="1" set="method" line="268"><f a=""><x path="Void"/></f></dispose>
		<_driverDisposer set="method" line="278"><f a=""><x path="Void"/></f></_driverDisposer>
		<new public="1" set="method" line="204"><f a="p_kernel:p_id:p_packageId:?p_audioChannelType:?p_loops:?p_startTime:?p_volume:?p_pan:?p_onCompleteCallback">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<c path="String"/>
	<e path="awe6.interfaces.EAudioChannel"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IFactory" params="" file="../../lib/awe6/interfaces/IFactory.hx" interface="1">
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc><![CDATA[* The unique identifier for this specific project.  <=16 chars, no spaces.]]></haxe_doc>
		</id>
		<version public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The current version of this specific project.  Suggestion: major.minor.revision - e.g. 1.2.345</haxe_doc>
		</version>
		<author public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The author or this specific project.</haxe_doc>
		</author>
		<isDebug public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* A convenient switch to allow debug modes or verbose output in your code.  Adjust as needed.</haxe_doc>
		</isDebug>
		<isDecached public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* A convenient switch to force all loaded content to be freshly loaded each request (rather than caching).</haxe_doc>
		</isDecached>
		<isEyeCandyOptionEnabled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Disable to hide any eye candy options.</haxe_doc>
		</isEyeCandyOptionEnabled>
		<isFullScreenOptionEnabled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Disable to hide any full screen options.</haxe_doc>
		</isFullScreenOptionEnabled>
		<isResetSessionsOptionEnabled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Disable to hide any session resetting options.</haxe_doc>
		</isResetSessionsOptionEnabled>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The horizontal width of this application's bounding rectangle.</haxe_doc>
		</width>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The vertical height of this application's bounding rectangle.</haxe_doc>
		</height>
		<bgColor public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The default background color of the application's bounding rectangle.</haxe_doc>
		</bgColor>
		<fullScreenType public="1" set="null">
			<e path="awe6.interfaces.EFullScreen"/>
			<haxe_doc>* The default scaling used for fullScreen mode.</haxe_doc>
		</fullScreenType>
		<joypadTouchType public="1" set="null">
			<e path="awe6.interfaces.EJoypadTouch"/>
			<haxe_doc>* The default handler for joypadTouch mode.</haxe_doc>
		</joypadTouchType>
		<secret public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The default secret key used to encrypt data.  Set it to something specific for your project, and conceal it's value.</haxe_doc>
		</secret>
		<targetFramerate public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The intended frequency of the update broad phase traversal stack.  Technical limitations may prevent desired framerate from occurring.</haxe_doc>
		</targetFramerate>
		<isFixedUpdates public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* If true will send the time between each update as if the targetFramerate was hit perfectly.  If false will send the actual time between each update (which will vary from update to update).</haxe_doc>
		</isFixedUpdates>
		<config public="1" set="null">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>* Dictionary of values.  Can be used to load initial configuration settings or store global variables.</haxe_doc>
		</config>
		<startingSceneType public="1" set="null">
			<e path="awe6.interfaces.EScene"/>
			<haxe_doc>* The scene which is displayed first.  The application starts here.</haxe_doc>
		</startingSceneType>
		<keyPause public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>* The default key used in this application to pause updates.</haxe_doc>
		</keyPause>
		<keyMute public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>* The default key used in this application to mute the audio.</haxe_doc>
		</keyMute>
		<keyBack public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>* The default key used in this application to back out of the current scene.</haxe_doc>
		</keyBack>
		<keyNext public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>* The default key used in this application to advance to the next scene.</haxe_doc>
		</keyNext>
		<keySpecial public="1" set="null">
			<e path="awe6.interfaces.EKey"/>
			<haxe_doc>* The default key used in this application to do a special action (determined by the specific application).</haxe_doc>
		</keySpecial>
		<onInitComplete public="1" set="method">
			<f a="kernel">
				<c path="awe6.interfaces.IKernel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by the kernel to complete initialization (due to both requiring an initialized instance of each).
	 * @param	kernel	An intialized kernel offering services to the factory.</haxe_doc>
		</onInitComplete>
		<createAssetManager public="1" set="method">
			<f a=""><c path="awe6.interfaces.IAssetManagerProcess"/></f>
			<haxe_doc>* Builds the application's asset manager which store images, sounds etc.
	 * @return	Asset manager.</haxe_doc>
		</createAssetManager>
		<createEncrypter public="1" set="method">
			<f a=""><c path="awe6.interfaces.IEncrypter"/></f>
			<haxe_doc>* Builds the application's encrypter to encrypt sensitive data / assets.
	 * @return Encrypter to encrypt sensitive data / assets.</haxe_doc>
		</createEncrypter>
		<createEntity public="1" set="method">
			<f a="?id">
				<d/>
				<c path="awe6.interfaces.IEntity"/>
			</f>
			<haxe_doc>* Builds an empty Entity for injection.
	 * @param	?id	The unique identifier of this entity.
	 * @return	An empty Entity.</haxe_doc>
		</createEntity>
		<createLogger public="1" set="method">
			<f a=""><c path="awe6.interfaces.ILogger"/></f>
			<haxe_doc>* Builds the application's logger to log events / analytics.
	 * @return	Logger to log events / analytics.</haxe_doc>
		</createLogger>
		<createOverlay public="1" set="method">
			<f a=""><c path="awe6.interfaces.IOverlayProcess"/></f>
			<haxe_doc>* Builds the application's overlay to decorate and provide top level functionality.
	 * @return	Overlay to decorate and provide top level functionality.</haxe_doc>
		</createOverlay>
		<createPreloader public="1" set="method">
			<f a=""><c path="awe6.interfaces.IPreloader"/></f>
			<haxe_doc>* Builds the application's preloader to load initial media assets.
	 * @return	Preloader to load initial media assets.</haxe_doc>
		</createPreloader>
		<createScene public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<c path="awe6.interfaces.IScene"/>
			</f>
			<haxe_doc>* Builds the application's scenes which contain specific functionality.
	 * @param	type	The type of scene.
	 * @return	Scene which contain specific functionality.</haxe_doc>
		</createScene>
		<createSceneTransition public="1" set="method">
			<f a="?typeIncoming:?typeOutgoing">
				<e path="awe6.interfaces.EScene"/>
				<e path="awe6.interfaces.EScene"/>
				<c path="awe6.interfaces.ISceneTransition"/>
			</f>
			<haxe_doc>* Builds the application's transition between scenes.  Can be individually tailored for any combination of incoming and outgoing scene.
	 * @param	?typeIncoming	The type of the incoming scene.
	 * @param	?typeOutgoing	The type of the outgoing scene.
	 * @return	Transition between scenes.</haxe_doc>
		</createSceneTransition>
		<createSession public="1" set="method">
			<f a="?id">
				<c path="String"/>
				<c path="awe6.interfaces.ISession"/>
			</f>
			<haxe_doc>* Builds the application's session to store user progress.
	 * @param	id	The unique identifier of the session.  If session already exists will load existing.
	 * @return	Session to store user progress.</haxe_doc>
		</createSession>
		<createTextStyle public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.ETextStyle"/>
				<c path="awe6.interfaces.ITextStyle"/>
			</f>
			<haxe_doc>* Builds the application's textStyle to configure font formatting.
	 * @param	?type	The type of textStyle.
	 * @return	TextStyle to configure font formatting.</haxe_doc>
		</createTextStyle>
		<getBackSceneType public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<e path="awe6.interfaces.EScene"/>
			</f>
			<haxe_doc>* When a scene is backed out of it will be replaced by the scene returned here.
	 * @param	type	Type of scene to back out from.
	 * @return	Scene type to back out to.</haxe_doc>
		</getBackSceneType>
		<getNextSceneType public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EScene"/>
				<e path="awe6.interfaces.EScene"/>
			</f>
			<haxe_doc>* When a scene requests the next scene it will be replaced by the scene returned here.
	 * @param	type	Type of scene to advance from.
	 * @return	Scene type to advance to next.</haxe_doc>
		</getNextSceneType>
		<haxe_doc><![CDATA[* The IFactory interface should be implemented by objects designed to populate an awe6 implementation.
 * <p>The IFactory represents the blueprint and builder for all project specific classes.</p>
 * @author Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AFactory" params="" file="../../lib/awe6/core/drivers/AFactory.hx">
		<implements path="awe6.interfaces.IDisposable"/>
		<implements path="awe6.interfaces.IFactory"/>
		<_CONFIG_ASSETS_NODE get="inline" set="null" line="69" static="1"><c path="String"/></_CONFIG_ASSETS_NODE>
		<_context><t path="awe6.core.Context"/></_context>
		<_config><c path="String"/></_config>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_concreteKernel><t path="awe6.core.Kernel"/></_concreteKernel>
		<_tools><c path="awe6.interfaces.ITools"/></_tools>
		<isDisposed public="1" set="null"><x path="Bool"/></isDisposed>
		<id public="1" set="null"><c path="String"/></id>
		<version public="1" set="null"><c path="String"/></version>
		<author public="1" set="null"><c path="String"/></author>
		<isDebug public="1" set="null"><x path="Bool"/></isDebug>
		<isDecached public="1" set="null"><x path="Bool"/></isDecached>
		<isEyeCandyOptionEnabled public="1" set="null"><x path="Bool"/></isEyeCandyOptionEnabled>
		<isFullScreenOptionEnabled public="1" set="null"><x path="Bool"/></isFullScreenOptionEnabled>
		<isResetSessionsOptionEnabled public="1" set="null"><x path="Bool"/></isResetSessionsOptionEnabled>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<bgColor public="1" set="null"><x path="Int"/></bgColor>
		<fullScreenType public="1" set="null"><e path="awe6.interfaces.EFullScreen"/></fullScreenType>
		<joypadTouchType public="1" set="null"><e path="awe6.interfaces.EJoypadTouch"/></joypadTouchType>
		<secret public="1" set="null"><c path="String"/></secret>
		<targetFramerate public="1" set="null"><x path="Int"/></targetFramerate>
		<isFixedUpdates public="1" set="null"><x path="Bool"/></isFixedUpdates>
		<config public="1" set="null"><x path="Map">
	<c path="String"/>
	<d/>
</x></config>
		<startingSceneType public="1" set="null"><e path="awe6.interfaces.EScene"/></startingSceneType>
		<keyPause public="1" set="null"><e path="awe6.interfaces.EKey"/></keyPause>
		<keyMute public="1" set="null"><e path="awe6.interfaces.EKey"/></keyMute>
		<keyBack public="1" set="null"><e path="awe6.interfaces.EKey"/></keyBack>
		<keyNext public="1" set="null"><e path="awe6.interfaces.EKey"/></keyNext>
		<keySpecial public="1" set="null"><e path="awe6.interfaces.EKey"/></keySpecial>
		<_init get="inline" set="null" line="110"><f a=""><x path="Void"/></f></_init>
		<_driverInit set="method" line="117"><f a=""><x path="Void"/></f></_driverInit>
		<_traverseElements set="method" line="127"><f a="p_elements:p_prefix">
	<t path="Iterator"><c path="Xml"/></t>
	<c path="String"/>
	<x path="Void"/>
</f></_traverseElements>
		<_configure get="inline" set="null" line="170"><f a="?p_isPreconfig">
	<x path="Bool"/>
	<x path="Void"/>
</f></_configure>
		<_configurer set="method" line="202">
			<f a="?p_isPreconfig">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	p_isPreconfig	Configurer is called twice.  Once before the config.xml has been passed (isPreconfig == true) and again later just before Kernel is instantiated (isPreconfig == false).  This allows some config to be redefined after the xml is loaded.  Whereas some config must be setup beforehand (e.g. secret key).</haxe_doc>
		</_configurer>
		<_launchKernel set="method" line="207"><f a=""><x path="Void"/></f></_launchKernel>
		<_getAssetUrls set="method" line="217"><f a=""><c path="Array"><c path="String"/></c></f></_getAssetUrls>
		<onInitComplete public="1" set="method" line="231"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></onInitComplete>
		<createAssetManager public="1" set="method" line="244"><f a=""><c path="awe6.interfaces.IAssetManagerProcess"/></f></createAssetManager>
		<createEncrypter public="1" set="method" line="256"><f a=""><c path="awe6.interfaces.IEncrypter"/></f></createEncrypter>
		<createEntity public="1" set="method" line="261"><f a="?p_id">
	<d/>
	<c path="awe6.interfaces.IEntity"/>
</f></createEntity>
		<createLogger public="1" set="method" line="266"><f a=""><c path="awe6.interfaces.ILogger"/></f></createLogger>
		<createOverlay public="1" set="method" line="271"><f a=""><c path="awe6.interfaces.IOverlayProcess"/></f></createOverlay>
		<createPreloader public="1" set="method" line="276"><f a=""><c path="awe6.interfaces.IPreloader"/></f></createPreloader>
		<createScene public="1" set="method" line="281"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<c path="awe6.interfaces.IScene"/>
</f></createScene>
		<createSceneTransition public="1" set="method" line="290"><f a="?p_typeIncoming:?p_typeOutgoing">
	<e path="awe6.interfaces.EScene"/>
	<e path="awe6.interfaces.EScene"/>
	<c path="awe6.interfaces.ISceneTransition"/>
</f></createSceneTransition>
		<createSession public="1" set="method" line="295"><f a="?p_id">
	<c path="String"/>
	<c path="awe6.interfaces.ISession"/>
</f></createSession>
		<createTextStyle public="1" set="method" line="300"><f a="?p_type">
	<e path="awe6.interfaces.ETextStyle"/>
	<c path="awe6.interfaces.ITextStyle"/>
</f></createTextStyle>
		<getBackSceneType public="1" set="method" line="305"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<e path="awe6.interfaces.EScene"/>
</f></getBackSceneType>
		<getNextSceneType public="1" set="method" line="310"><f a="p_type">
	<e path="awe6.interfaces.EScene"/>
	<e path="awe6.interfaces.EScene"/>
</f></getNextSceneType>
		<dispose public="1" set="method" line="315"><f a=""><x path="Void"/></f></dispose>
		<_driverDisposer set="method" line="329"><f a=""><x path="Void"/></f></_driverDisposer>
		<new public="1" set="method" line="102"><f a="p_context:?p_isDebug:?p_config">
	<t path="awe6.core.Context"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The AFactory class provides a minimalist abstract implementation of the IFactory interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IInputKeyboard" params="" file="../../lib/awe6/interfaces/IInputKeyboard.hx" interface="1">
		<getIsKeyDown public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if a specific key is currently down.
	 * @param	type	They key.
	 * @return	Returns true is the key is currently down, false otherwise.</haxe_doc>
		</getIsKeyDown>
		<getIsKeyPress public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if a specific key was pressed in the current update frame.
	 * <p>A press is defined as a new down - i.e. was up previous frame, and is down this frame.</p>
	 * @param	type	The key.
	 * @return	Returns true is the key was pressed in the current update, false otherwise.]]></haxe_doc>
		</getIsKeyPress>
		<getIsKeyRelease public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if a specific key was released in the current update.
	 * <p>A release is defined as a new up - i.e. was down previous frame, and is up this frame.</p>
	 * @param	type	The key.
	 * @return	Returns true is the key was released in the current update, false otherwise.]]></haxe_doc>
		</getIsKeyRelease>
		<getKeyDownDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EKey"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine how long a specific key has been down.
	 * @param	type	The key.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration down (the time held prior to the most recent release).
	 * @return	Returns the duration the key has been down.</haxe_doc>
		</getKeyDownDuration>
		<getKeyUpDuration public="1" set="method">
			<f a="type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EKey"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine how long a specific key has been up.
	 * @param	type	The key.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration up (the time unused prior to the most recent press).
	 * @return	Returns the duration the key has been up.</haxe_doc>
		</getKeyUpDuration>
		<getKeyCode public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EKey"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Translate a specific key to a keyboard keyCode.
	 * @param	type	The key.
	 * @return	Returns the keyboard keyCode of the corresponding key.</haxe_doc>
		</getKeyCode>
		<getKey public="1" set="method">
			<f a="keyCode">
				<x path="Int"/>
				<e path="awe6.interfaces.EKey"/>
			</f>
			<haxe_doc>* Translate a keyCode to a specific key.
	 * @param	type	The keyCode.
	 * @return	Returns the key of the corresponding keyboard keyCode.</haxe_doc>
		</getKey>
		<haxe_doc>* The IInputKeyboard interface should be implemented by an object wishing to be used as a virtual keyboard input device.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.drivers.AInputKeyboard" params="" file="../../lib/awe6/core/drivers/AInputKeyboard.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IInputKeyboard"/>
		<_keys><c path="Array"><c path="awe6.core.drivers._AInputKeyboard._HelperKey"/></c></_keys>
		<_buffer><c path="Array"><c path="awe6.core.drivers._AInputKeyboard._HelperKeyEvent"/></c></_buffer>
		<_init set="method" line="47" override="1"><f a=""><x path="Void"/></f></_init>
		<_driverInit set="method" line="54"><f a=""><x path="Void"/></f></_driverInit>
		<_updater set="method" line="59" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="97" override="1"><f a=""><x path="Void"/></f></_disposer>
		<_addEvent set="method" line="103"><f a="p_keyCodeValue:p_isDown">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_addEvent>
		<_onDown set="method" line="108"><f a="p_keyCode">
	<x path="Int"/>
	<x path="Void"/>
</f></_onDown>
		<_onUp set="method" line="119"><f a="p_keyCode">
	<x path="Int"/>
	<x path="Void"/>
</f></_onUp>
		<_reset set="method" line="129"><f a="?p_event">
	<d/>
	<x path="Void"/>
</f></_reset>
		<getIsKeyDown public="1" set="method" line="139"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<x path="Bool"/>
</f></getIsKeyDown>
		<getIsKeyPress public="1" set="method" line="149"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<x path="Bool"/>
</f></getIsKeyPress>
		<getIsKeyRelease public="1" set="method" line="159"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<x path="Bool"/>
</f></getIsKeyRelease>
		<getKeyDownDuration public="1" set="method" line="169"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EKey"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getKeyDownDuration>
		<getKeyUpDuration public="1" set="method" line="183"><f a="p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EKey"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getKeyUpDuration>
		<getKeyCode public="1" set="method" line="197"><f a="p_type">
	<e path="awe6.interfaces.EKey"/>
	<x path="Int"/>
</f></getKeyCode>
		<getKey public="1" set="method" line="404"><f a="p_keyCode">
	<x path="Int"/>
	<e path="awe6.interfaces.EKey"/>
</f></getKey>
		<new public="1" set="method" line="42"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The InputKeyboard class provides a minimalist implementation of the IInputKeyboard interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers._AInputKeyboard._HelperKey" params="" file="../../lib/awe6/core/drivers/AInputKeyboard.hx" private="1" module="awe6.core.drivers.AInputKeyboard">
		<isUsed public="1"><x path="Bool"/></isUsed>
		<isDown public="1"><x path="Bool"/></isDown>
		<updatesDown public="1"><x path="Int"/></updatesDown>
		<updatesUp public="1"><x path="Int"/></updatesUp>
		<timeDown public="1"><x path="Int"/></timeDown>
		<timeUp public="1"><x path="Int"/></timeUp>
		<updatesDownPrevious public="1"><x path="Int"/></updatesDownPrevious>
		<updatesUpPrevious public="1"><x path="Int"/></updatesUpPrevious>
		<timeDownPrevious public="1"><x path="Int"/></timeDownPrevious>
		<timeUpPrevious public="1"><x path="Int"/></timeUpPrevious>
		<new public="1" set="method" line="433"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers._AInputKeyboard._HelperKeyEvent" params="" file="../../lib/awe6/core/drivers/AInputKeyboard.hx" private="1" module="awe6.core.drivers.AInputKeyboard">
		<keyCode public="1"><x path="Int"/></keyCode>
		<isDown public="1"><x path="Bool"/></isDown>
		<new public="1" set="method" line="452"><f a="p_keyCode:p_isDown">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IInputMouse" params="" file="../../lib/awe6/interfaces/IInputMouse.hx" interface="1">
		<set_isVisible public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_isVisible>
		<set_cursorType public="1" set="method">
			<f a="value">
				<e path="awe6.interfaces.EMouseCursor"/>
				<e path="awe6.interfaces.EMouseCursor"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_cursorType>
		<x public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The horizontal component of the mouse position.</haxe_doc>
		</x>
		<y public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The vertical component of the mouse position.</haxe_doc>
		</y>
		<relativeX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal position of the mouse relative to screen width.  Range 0...1.</haxe_doc>
		</relativeX>
		<relativeY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical position of the mouse relative to screen height.  Range 0...1.</haxe_doc>
		</relativeY>
		<relativeCentralisedX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal position of the mouse relative to screen width and offset to screen centre.  Range -1...1.</haxe_doc>
		</relativeCentralisedX>
		<relativeCentralisedY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical position of the mouse relative to screen height and offset to screen centre.  Range -1...1.</haxe_doc>
		</relativeCentralisedY>
		<isWithinBounds public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Returns true if the mouse position is within the bounding rectangle (factory width x factory height).</haxe_doc>
		</isWithinBounds>
		<isMoving public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Returns true if the mouse position is different to the previous update's position.</haxe_doc>
		</isMoving>
		<isVisible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specify the visibility of the mouse cursor.
	 * <p>If true the cursor will be displayed, if false the cursor is hidden.</p>]]></haxe_doc>
		</isVisible>
		<scroll public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The current scroll position.  Starts at 0.  Range -infinity...infinity.</haxe_doc>
		</scroll>
		<cursorType public="1" set="accessor">
			<e path="awe6.interfaces.EMouseCursor"/>
			<haxe_doc>* The current cursor type.</haxe_doc>
		</cursorType>
		<getDeltaX public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The horizontal velocity of the mouse position.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as pixels moved in previous update.
	 * @return	The horizontal velocity of the mouse.</haxe_doc>
		</getDeltaX>
		<getDeltaY public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The vertical velocity of the mouse position.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as pixels moved in previous update.
	 * @return	The vertical velocity of the mouse.</haxe_doc>
		</getDeltaY>
		<getSpeed public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The velocity of the mouse.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as pixels moved in previous update.
	 * @return	The velocity of the mouse.</haxe_doc>
		</getSpeed>
		<getDeltaScroll public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The velocity of scrolling.
	 * @param	?asTime	If true then returns the velocity as pixels per second (extrapolated from the previous update), else returns velocity as scroll moved in previous update.
	 * @return	The scroll velocity of the mouse.</haxe_doc>
		</getDeltaScroll>
		<getStillDuration public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine how long the mouse has been still.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @return	Returns the duration the mouse has been still.</haxe_doc>
		</getStillDuration>
		<getIsButtonDoubleClick public="1" set="method">
			<f a="?type:?delay">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if a specific mouse button was clicked twice (within the defined time).
	 * @param	?type	The mouse button.
	 * @param	?delay	The time within which the mouse button must be clicked twice.
	 * @return	Returns true if the mouse button was clicked twice (within the defined time).</haxe_doc>
		</getIsButtonDoubleClick>
		<getIsButtonDrag public="1" set="method">
			<f a="?type:?delay">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if the mouse is being dragged with a specific mouse button down (for at least the defined delay).
	 * @param	?type	The mouse button.
	 * @param	?delay	The time which, if exceeded, assumes the mouse is being dragged. 
	 * @return	Returns true if the mouse button was down for a duration exceeding delay.</haxe_doc>
		</getIsButtonDrag>
		<getIsButtonDown public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determine if a specific mouse button is currently down.
	 * @param	?type	The mouse button.
	 * @return	Returns true is the mouse button is currently down, false otherwise.</haxe_doc>
		</getIsButtonDown>
		<getIsButtonPress public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if a specific mouse button was pressed in the current update frame.
	 * <p>A press is defined as a new down - i.e. was up previous frame, and is down this frame.</p>
	 * @param	type	The mouse button.
	 * @return	Returns true is the mouse button was pressed in the current update, false otherwise.]]></haxe_doc>
		</getIsButtonPress>
		<getIsButtonRelease public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determine if a specific mouse button was released in the current update.
	 * <p>A release is defined as a new up - i.e. was down previous frame, and is up this frame.</p>
	 * @param	type	The mouse button.
	 * @return	Returns true is the mouse button was released in the current update, false otherwise.]]></haxe_doc>
		</getIsButtonRelease>
		<getButtonDownDuration public="1" set="method">
			<f a="?type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine the duration a specific mouse button is down.
	 * @param	?type	The mouse button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration down (the time held prior to the most recent release).
	 * @return	The duration a specific mouse button is down.</haxe_doc>
		</getButtonDownDuration>
		<getButtonUpDuration public="1" set="method">
			<f a="?type:?asTime:?isPrevious">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine the duration a specific mouse button is up.
	 * @param	?type	The mouse button.
	 * @param	?asTime	If true then returns duration as milliseconds, else returns duration as frame updates.
	 * @param	?isPrevious	If true then returns the previous duration up (the time unused prior to the most recent press).
	 * @return	The duration a specific mouse button is up.</haxe_doc>
		</getButtonUpDuration>
		<getButtonDragWidth public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine the horizontal movement of the mouse since a specific mouse button was pressed.
	 * @param	?type	The mouse button.
	 * @return	The horizontal movement of the mouse.</haxe_doc>
		</getButtonDragWidth>
		<getButtonDragHeight public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine the vertical movement of the mouse since a specific mouse button was pressed.
	 * @param	?type	The mouse button.
	 * @return	The vertical movement of the mouse.</haxe_doc>
		</getButtonDragHeight>
		<getButtonLastClickedX public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine the horizontal position of the mouse when a specific mouse button was last clicked.
	 * @param	?type	The mouse button.
	 * @return	The horizontal position of the mouse.</haxe_doc>
		</getButtonLastClickedX>
		<getButtonLastClickedY public="1" set="method">
			<f a="?type">
				<e path="awe6.interfaces.EMouseButton"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Determine the vertical position of the mouse when a specific mouse button was last clicked.
	 * @param	?type	The mouse button.
	 * @return	The vertical position of the mouse.</haxe_doc>
		</getButtonLastClickedY>
		<haxe_doc><![CDATA[* The IInputMouse interface should be implemented by objects wishing to act as virtual mouse controllers.
 * <p>Screen bounds are based on IFactory.width & IFactory.height.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AInputMouse" params="" file="../../lib/awe6/core/drivers/AInputMouse.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IInputMouse"/>
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<relativeX public="1" set="null"><x path="Float"/></relativeX>
		<relativeY public="1" set="null"><x path="Float"/></relativeY>
		<relativeCentralisedX public="1" set="null"><x path="Float"/></relativeCentralisedX>
		<relativeCentralisedY public="1" set="null"><x path="Float"/></relativeCentralisedY>
		<isWithinBounds public="1" set="null"><x path="Bool"/></isWithinBounds>
		<isMoving public="1" set="null"><x path="Bool"/></isMoving>
		<scroll public="1" set="null"><x path="Int"/></scroll>
		<isVisible public="1" set="accessor"><x path="Bool"/></isVisible>
		<cursorType public="1" set="accessor"><e path="awe6.interfaces.EMouseCursor"/></cursorType>
		<_buffer><c path="Array"><x path="Bool"/></c></_buffer>
		<_xPrev><x path="Int"/></_xPrev>
		<_yPrev><x path="Int"/></_yPrev>
		<_deltaX><x path="Int"/></_deltaX>
		<_deltaY><x path="Int"/></_deltaY>
		<_deltaTimePrev><x path="Int"/></_deltaTimePrev>
		<_deltaScroll><x path="Int"/></_deltaScroll>
		<_scrollPrev><x path="Int"/></_scrollPrev>
		<_stillUpdates><x path="Int"/></_stillUpdates>
		<_stillDuration><x path="Int"/></_stillDuration>
		<_buttonLeft><c path="awe6.core.drivers._AInputMouse._HelperButton"/></_buttonLeft>
		<_buttonMiddle><c path="awe6.core.drivers._AInputMouse._HelperButton"/></_buttonMiddle>
		<_buttonRight><c path="awe6.core.drivers._AInputMouse._HelperButton"/></_buttonRight>
		<_init set="method" line="72" override="1"><f a=""><x path="Void"/></f></_init>
		<_driverInit set="method" line="91"><f a=""><x path="Void"/></f></_driverInit>
		<_updater set="method" line="96" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_isMiddleDown set="method" line="130"><f a=""><x path="Bool"/></f></_isMiddleDown>
		<_isRightDown set="method" line="135"><f a=""><x path="Bool"/></f></_isRightDown>
		<_isWithinBounds set="method" line="140"><f a=""><x path="Bool"/></f></_isWithinBounds>
		<_getPosition set="method" line="145"><f a=""><x path="Void"/></f></_getPosition>
		<_handleButton set="method" line="151"><f a="p_type:p_isDown:?p_deltaTime">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_handleButton>
		<_disposer set="method" line="182" override="1"><f a=""><x path="Void"/></f></_disposer>
		<_reset set="method" line="187"><f a="?p_event">
	<d/>
	<x path="Void"/>
</f></_reset>
		<_getButton set="method" line="195"><f a="p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<c path="awe6.core.drivers._AInputMouse._HelperButton"/>
</f></_getButton>
		<getDeltaX public="1" set="method" line="212"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getDeltaX>
		<getDeltaY public="1" set="method" line="222"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getDeltaY>
		<getSpeed public="1" set="method" line="232"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getSpeed>
		<getDeltaScroll public="1" set="method" line="240"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getDeltaScroll>
		<getIsButtonDoubleClick public="1" set="method" line="250"><f a="?p_type:?p_delay">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getIsButtonDoubleClick>
		<getIsButtonDrag public="1" set="method" line="256"><f a="?p_type:?p_delay">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getIsButtonDrag>
		<getStillDuration public="1" set="method" line="262"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getStillDuration>
		<getIsButtonDown public="1" set="method" line="267"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Bool"/>
</f></getIsButtonDown>
		<getIsButtonPress public="1" set="method" line="273"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Bool"/>
</f></getIsButtonPress>
		<getIsButtonRelease public="1" set="method" line="279"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Bool"/>
</f></getIsButtonRelease>
		<getButtonDownDuration public="1" set="method" line="285"><f a="?p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getButtonDownDuration>
		<getButtonUpDuration public="1" set="method" line="295"><f a="?p_type:?p_asTime:?p_isPrevious">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></getButtonUpDuration>
		<getButtonDragWidth public="1" set="method" line="305"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Int"/>
</f></getButtonDragWidth>
		<getButtonDragHeight public="1" set="method" line="311"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Int"/>
</f></getButtonDragHeight>
		<getButtonLastClickedX public="1" set="method" line="317"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Int"/>
</f></getButtonLastClickedX>
		<getButtonLastClickedY public="1" set="method" line="323"><f a="?p_type">
	<e path="awe6.interfaces.EMouseButton"/>
	<x path="Int"/>
</f></getButtonLastClickedY>
		<set_isVisible set="method" line="329"><f a="p_value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isVisible>
		<set_cursorType set="method" line="335"><f a="p_value">
	<e path="awe6.interfaces.EMouseCursor"/>
	<e path="awe6.interfaces.EMouseCursor"/>
</f></set_cursorType>
		<new public="1" set="method" line="44"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The InputMouse class provides a minimalist implementation of the IInputMouse interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers._AInputMouse._HelperButton" params="" file="../../lib/awe6/core/drivers/AInputMouse.hx" private="1" module="awe6.core.drivers.AInputMouse">
		<isDown public="1"><x path="Bool"/></isDown>
		<updatesDown public="1"><x path="Int"/></updatesDown>
		<updatesUp public="1"><x path="Int"/></updatesUp>
		<timeDown public="1"><x path="Int"/></timeDown>
		<timeUp public="1"><x path="Int"/></timeUp>
		<updatesDownPrevious public="1"><x path="Int"/></updatesDownPrevious>
		<updatesUpPrevious public="1"><x path="Int"/></updatesUpPrevious>
		<timeDownPrevious public="1"><x path="Int"/></timeDownPrevious>
		<timeUpPrevious public="1"><x path="Int"/></timeUpPrevious>
		<clickX public="1"><x path="Int"/></clickX>
		<clickY public="1"><x path="Int"/></clickY>
		<new public="1" set="method" line="357"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.ILogger" params="" file="../../lib/awe6/interfaces/ILogger.hx" interface="1">
		<log public="1" set="method">
			<f a="value">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pass a value to the logger to log.
	 * @param	value	The value (can be anything).</haxe_doc>
		</log>
		<haxe_doc><![CDATA[* The ILogger interface should be implemented by objects wishing to act as logging services.
 * <p>Logging services are useful for debugging or analytics.</p>
 * <p>The interface is intentionally vague to allow a multitude of implementations.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IKernel" params="" file="../../lib/awe6/interfaces/IKernel.hx" interface="1">
		<extends path="awe6.interfaces.ILogger"/>
		<extends path="awe6.interfaces.IPauseable"/>
		<set_isEyeCandy public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_isEyeCandy>
		<set_isFullScreen public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_isFullScreen>
		<get_session public="1" set="method">
			<f a=""><c path="awe6.interfaces.ISession"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_session>
		<set_session public="1" set="method">
			<f a="value">
				<c path="awe6.interfaces.ISession"/>
				<c path="awe6.interfaces.ISession"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_session>
		<isDebug public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Defined by the IFactory, can be used for conditional logic relating to build modes and debug.</haxe_doc>
		</isDebug>
		<isLocal public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Identifies a non network location, can be used for conditional logic relating to build modes and debug.</haxe_doc>
		</isLocal>
		<isEyeCandy public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Toggleable by the user, intended to be used as a switch to disable intensive, but non essential, content (performance vs wow).</haxe_doc>
		</isEyeCandy>
		<isFullScreen public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Toggleable by the user, enables or disables full screen mode.</haxe_doc>
		</isFullScreen>
		<overlay public="1" set="null">
			<c path="awe6.interfaces.IOverlay"/>
			<haxe_doc><![CDATA[* The topmost visual element, used for chrome & global controls.]]></haxe_doc>
		</overlay>
		<assets public="1" set="null">
			<c path="awe6.interfaces.IAssetManager"/>
			<haxe_doc>* Assets manager.</haxe_doc>
		</assets>
		<audio public="1" set="null">
			<c path="awe6.interfaces.IAudioManager"/>
			<haxe_doc>* Audio manager.</haxe_doc>
		</audio>
		<inputs public="1" set="null">
			<c path="awe6.interfaces.IInputManager"/>
			<haxe_doc>* Inputs manager.</haxe_doc>
		</inputs>
		<scenes public="1" set="null">
			<c path="awe6.interfaces.ISceneManager"/>
			<haxe_doc>* Scene manager.  State machine containing IEntities.</haxe_doc>
		</scenes>
		<messenger public="1" set="null">
			<c path="awe6.interfaces.IMessageManager"/>
			<haxe_doc>* Messenger manager.  Arbitrator for observer pattern across IEntityCollections.</haxe_doc>
		</messenger>
		<tools public="1" set="null">
			<c path="awe6.interfaces.ITools"/>
			<haxe_doc>* Helper methods.</haxe_doc>
		</tools>
		<factory public="1" set="null">
			<c path="awe6.interfaces.IFactory"/>
			<haxe_doc>* Build properties and factory methods to create the application.</haxe_doc>
		</factory>
		<session public="1" get="accessor" set="accessor">
			<c path="awe6.interfaces.ISession"/>
			<haxe_doc>* Read and write globally accessible variables.</haxe_doc>
		</session>
		<getConfig public="1" set="method">
			<f a="id">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Used for read only application settings and localisation text.
	 * @param	id	The unique identifier for the config setting (e.g. XML node name).
	 * @return	Value of the corresponding config setting.</haxe_doc>
		</getConfig>
		<getFramerate public="1" set="method">
			<f a="?asActual">
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Request the framerate of the application.
	 * @param	?asActual	Use actual framerate (potentially laggy), or the desired framerate (from IFactory).
	 * @return	Frames per second.</haxe_doc>
		</getFramerate>
		<onPreloaderComplete public="1" set="method">
			<f a="preloader">
				<c path="awe6.interfaces.IPreloader"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal method called when preloader completes; launches the starting scene as defined by IFactory.startingSceneType.
	 * @param	preloader	Corresponding IPreloader.</haxe_doc>
		</onPreloaderComplete>
		<haxe_doc>* Handles main updates and provides global locators for all managers
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.drivers.AKernel" params="" file="../../lib/awe6/core/drivers/AKernel.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IKernel"/>
		<_POWERED_BY get="inline" set="null" line="69" static="1"><c path="String"/></_POWERED_BY>
		<_POWERED_BY_URL get="inline" set="null" line="70" static="1"><c path="String"/></_POWERED_BY_URL>
		<_RELEASE_CAUTION get="inline" set="null" line="71" static="1"><c path="String"/></_RELEASE_CAUTION>
		<_RESET_SESSIONS get="inline" set="null" line="72" static="1"><c path="String"/></_RESET_SESSIONS>
		<_EYE_CANDY_ENABLE get="inline" set="null" line="73" static="1"><c path="String"/></_EYE_CANDY_ENABLE>
		<_EYE_CANDY_DISABLE get="inline" set="null" line="74" static="1"><c path="String"/></_EYE_CANDY_DISABLE>
		<_FULL_SCREEN_ENABLE get="inline" set="null" line="75" static="1"><c path="String"/></_FULL_SCREEN_ENABLE>
		<_FULL_SCREEN_DISABLE get="inline" set="null" line="76" static="1"><c path="String"/></_FULL_SCREEN_DISABLE>
		<overlay public="1" set="null"><c path="awe6.interfaces.IOverlay"/></overlay>
		<factory public="1" set="null"><c path="awe6.interfaces.IFactory"/></factory>
		<isDebug public="1" set="null"><x path="Bool"/></isDebug>
		<isLocal public="1" set="null"><x path="Bool"/></isLocal>
		<tools public="1" set="null"><c path="awe6.interfaces.ITools"/></tools>
		<assets public="1" set="null"><c path="awe6.interfaces.IAssetManager"/></assets>
		<audio public="1" set="null"><c path="awe6.interfaces.IAudioManager"/></audio>
		<inputs public="1" set="null"><c path="awe6.interfaces.IInputManager"/></inputs>
		<scenes public="1" set="null"><c path="awe6.interfaces.ISceneManager"/></scenes>
		<messenger public="1" set="null"><c path="awe6.interfaces.IMessageManager"/></messenger>
		<isEyeCandy public="1" set="accessor"><x path="Bool"/></isEyeCandy>
		<isFullScreen public="1" set="accessor"><x path="Bool"/></isFullScreen>
		<session public="1" get="accessor" set="accessor">
			<c path="awe6.interfaces.ISession"/>
			<meta><m n=":isVar"/></meta>
		</session>
		<_context><t path="awe6.core.Context"/></_context>
		<_view><t path="awe6.core.View"/></_view>
		<_assetManagerProcess><c path="awe6.interfaces.IAssetManagerProcess"/></_assetManagerProcess>
		<_audioManager><t path="awe6.core.AudioManager"/></_audioManager>
		<_inputManager><c path="awe6.core.InputManager"/></_inputManager>
		<_sceneManager><c path="awe6.core.SceneManager"/></_sceneManager>
		<_messageManager><c path="awe6.core.MessageManager"/></_messageManager>
		<_overlayProcess><c path="awe6.interfaces.IOverlayProcess"/></_overlayProcess>
		<_logger><c path="awe6.interfaces.ILogger"/></_logger>
		<_isPreloaded><x path="Bool"/></_isPreloaded>
		<_preloader><c path="awe6.interfaces.IPreloader"/></_preloader>
		<_profiler><t path="awe6.core.Profiler"/></_profiler>
		<_processes><c path="List"><c path="awe6.interfaces.IProcess"/></c></_processes>
		<_helperFramerate><c path="awe6.core.drivers._AKernel._HelperFramerate"/></_helperFramerate>
		<_init set="method" line="115" override="1"><f a=""><x path="Void"/></f></_init>
		<_driverGetIsLocal set="method" line="155"><f a=""><x path="Bool"/></f></_driverGetIsLocal>
		<_driverInit set="method" line="161"><f a=""><x path="Void"/></f></_driverInit>
		<_driverDisposer set="method" line="166"><f a=""><x path="Void"/></f></_driverDisposer>
		<onPreloaderComplete public="1" set="method" line="171"><f a="p_preloader">
	<c path="awe6.interfaces.IPreloader"/>
	<x path="Void"/>
</f></onPreloaderComplete>
		<_updater set="method" line="196" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="208" override="1"><f a=""><x path="Void"/></f></_disposer>
		<getConfig public="1" set="method" line="235"><f a="p_id">
	<c path="String"/>
	<d/>
</f></getConfig>
		<log public="1" set="method" line="240"><f a="p_value">
	<d/>
	<x path="Void"/>
</f></log>
		<getFramerate public="1" set="method" line="252"><f a="?p_asActual">
	<x path="Bool"/>
	<x path="Float"/>
</f></getFramerate>
		<_addProcess set="method" line="257"><f a="p_process:?p_isLast">
	<c path="awe6.interfaces.IProcess"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></_addProcess>
		<_removeProcess set="method" line="273"><f a="p_process">
	<c path="awe6.interfaces.IProcess"/>
	<x path="Bool"/>
</f></_removeProcess>
		<_totalReset set="method" line="283"><f a=""><x path="Void"/></f></_totalReset>
		<set_isEyeCandy set="method" line="294"><f a="p_value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isEyeCandy>
		<_driverSetIsEyeCandy set="method" line="306"><f a="p_value">
	<x path="Bool"/>
	<x path="Void"/>
</f></_driverSetIsEyeCandy>
		<set_isFullScreen set="method" line="311"><f a="p_value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isFullScreen>
		<_driverSetIsFullScreen set="method" line="323"><f a="p_value">
	<x path="Bool"/>
	<x path="Void"/>
</f></_driverSetIsFullScreen>
		<_pauser set="method" line="328" override="1"><f a=""><x path="Void"/></f></_pauser>
		<_resumer set="method" line="337" override="1"><f a=""><x path="Void"/></f></_resumer>
		<get_session set="method" line="346"><f a=""><c path="awe6.interfaces.ISession"/></f></get_session>
		<set_session set="method" line="351"><f a="p_value">
	<c path="awe6.interfaces.ISession"/>
	<c path="awe6.interfaces.ISession"/>
</f></set_session>
		<new public="1" set="method" line="107"><f a="p_factory:p_context">
	<c path="awe6.interfaces.IFactory"/>
	<t path="awe6.core.Context"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The AKernel class provides a minimalist implementation of the IKernel interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell
 * @author	Mihail Ivanchev]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers._AKernel._HelperFramerate" params="" file="../../lib/awe6/core/drivers/AKernel.hx" private="1" module="awe6.core.drivers.AKernel">
		<framerate public="1" set="null"><x path="Float"/></framerate>
		<timeInterval public="1" set="null"><x path="Int"/></timeInterval>
		<_timeAtLastUpdate><x path="Int"/></_timeAtLastUpdate>
		<update public="1" set="method" line="370"><f a=""><x path="Void"/></f></update>
		<_timer get="inline" set="null" line="377"><f a=""><x path="Int"/></f></_timer>
		<new public="1" set="method" line="364"><f a="p_framerate">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IOverlay" params="" file="../../lib/awe6/interfaces/IOverlay.hx" interface="1">
		<get_pauseEntity public="1" set="method">
			<f a=""><c path="awe6.interfaces.IEntity"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_pauseEntity>
		<set_pauseEntity public="1" set="method">
			<f a="value">
				<c path="awe6.interfaces.IEntity"/>
				<c path="awe6.interfaces.IEntity"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_pauseEntity>
		<pauseEntity public="1" get="accessor" set="accessor">
			<c path="awe6.interfaces.IEntity"/>
			<haxe_doc>* An optional IEntity which is displayed and updated when the game is paused.</haxe_doc>
		</pauseEntity>
		<showButton public="1" set="method">
			<f a="type:?isVisible">
				<e path="awe6.interfaces.EOverlayButton"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the visibility of a specific overlay button.
	 * @param	type	The overlay button.
	 * @param	?isVisible	If true shows the button, if false hides it.</haxe_doc>
		</showButton>
		<positionButton public="1" set="method">
			<f a="type:x:y:?width:?height">
				<e path="awe6.interfaces.EOverlayButton"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the position of a specific overlay button.
	 * @param	type	The overlay button.
	 * @param	x	The horizontal position.
	 * @param	y	The vertical position.
	 * @param	width	The width of the button hitArea, if null will not redefine.
	 * @param	height	The height of the button hitArea, if null will not redefine.</haxe_doc>
		</positionButton>
		<activateButton public="1" set="method">
			<f a="type">
				<e path="awe6.interfaces.EOverlayButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggers an overlay button (as if it was clicked on).
	 * @param	type	The overlay button.</haxe_doc>
		</activateButton>
		<showProgress public="1" set="method">
			<f a="progress:?message">
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Simple representation of progress.
	 * @param	progress	Range: 0...1.
	 * @param	?message	An optional string to display.</haxe_doc>
		</showProgress>
		<hideButtons public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hides all overlay buttons.</haxe_doc>
		</hideButtons>
		<flash public="1" set="method">
			<f a="?duration:?asTime:?startingAlpha:?color">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a flash over the top of everything under the overlay.  Fades to invisible over a period of time.
	 * @param	?duration	The period of time over which the flash should fade to 0.
	 * @param	?asTime	If true treats the time as milliseconds, otherwise as frame updates.
	 * @param	?startingAlpha	The alpha at which the flash starts.  Range: 0...1.
	 * @param	?color	The color of the flash.  Defaults to white.</haxe_doc>
		</flash>
		<haxe_doc><![CDATA[* The IOverlay interface should be implemented by objects representing the top most visual element of the application.
 * <p>The overlay is intended to provide application wide border / chrome with controls such as back, mute, pause etc.</p>
 * <p>The overlay also provides flashing which is a useful cheap effect across many game scenarios.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.interfaces.IOverlayProcess" params="" file="../../lib/awe6/interfaces/IOverlayProcess.hx" interface="1">
		<extends path="awe6.interfaces.IViewable"/>
		<extends path="awe6.interfaces.IProcess"/>
		<extends path="awe6.interfaces.IOverlay"/>
		<haxe_doc><![CDATA[* The IOverlayProcess interface should be implemented by objects representing an operating IOverlay.
 * <p>These extra interface requirements are required for internal workings, but are not exposed via the minimal IOverlay interface.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.AOverlay" params="" file="../../lib/awe6/core/drivers/AOverlay.hx">
		<extends path="awe6.core.Entity"/>
		<implements path="awe6.interfaces.IOverlayProcess"/>
		<pauseEntity public="1" get="accessor" set="accessor">
			<c path="awe6.interfaces.IEntity"/>
			<meta><m n=":isVar"/></meta>
		</pauseEntity>
		<_borderView><c path="awe6.interfaces.IView"/></_borderView>
		<_progressContext><t path="awe6.core.Context"/></_progressContext>
		<_progressView><c path="awe6.interfaces.IView"/></_progressView>
		<_pauseContext><t path="awe6.core.Context"/></_pauseContext>
		<_pauseView><c path="awe6.interfaces.IView"/></_pauseView>
		<_flashContext><t path="awe6.core.Context"/></_flashContext>
		<_flashView><c path="awe6.interfaces.IView"/></_flashView>
		<_context><t path="awe6.core.Context"/></_context>
		<_pauseColor><x path="Int"/></_pauseColor>
		<_pauseAlpha><x path="Float"/></_pauseAlpha>
		<_pauseBlur><x path="Float"/></_pauseBlur>
		<_flashDuration><x path="Float"/></_flashDuration>
		<_flashAlpha><x path="Float"/></_flashAlpha>
		<_flashStartingAlpha><x path="Float"/></_flashStartingAlpha>
		<_flashStartingDuration><x path="Float"/></_flashStartingDuration>
		<_flashAsTime><x path="Bool"/></_flashAsTime>
		<_wasMute><x path="Bool"/></_wasMute>
		<_buttonBack><c path="awe6.core.BasicButton"/></_buttonBack>
		<_buttonMute><c path="awe6.core.BasicButton"/></_buttonMute>
		<_buttonUnmute><c path="awe6.core.BasicButton"/></_buttonUnmute>
		<_buttonPause><c path="awe6.core.BasicButton"/></_buttonPause>
		<_buttonUnpause><c path="awe6.core.BasicButton"/></_buttonUnpause>
		<_init set="method" line="133" override="1"><f a=""><x path="Void"/></f></_init>
		<_driverInit set="method" line="179"><f a=""><x path="Void"/></f></_driverInit>
		<_updater set="method" line="187" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="215" override="1"><f a=""><x path="Void"/></f></_disposer>
		<_getButton set="method" line="225"><f a="p_type">
	<e path="awe6.interfaces.EOverlayButton"/>
	<c path="awe6.core.BasicButton"/>
</f></_getButton>
		<showButton public="1" set="method" line="245"><f a="p_type:?p_isVisible">
	<e path="awe6.interfaces.EOverlayButton"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></showButton>
		<positionButton public="1" set="method" line="262"><f a="p_type:p_x:p_y:?p_width:?p_height">
	<e path="awe6.interfaces.EOverlayButton"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></positionButton>
		<showProgress public="1" set="method" line="281"><f a="p_progress:?p_message">
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></showProgress>
		<hideButtons public="1" set="method" line="286"><f a=""><x path="Void"/></f></hideButtons>
		<flash public="1" set="method" line="295"><f a="?p_duration:?p_asTime:?p_startingAlpha:?p_color">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></flash>
		<activateButton public="1" set="method" line="303"><f a="p_type">
	<e path="awe6.interfaces.EOverlayButton"/>
	<x path="Void"/>
</f></activateButton>
		<_drawPause set="method" line="357"><f a="?p_isVisible">
	<x path="Bool"/>
	<x path="Void"/>
</f></_drawPause>
		<get_pauseEntity set="method" line="362"><f a=""><c path="awe6.interfaces.IEntity"/></f></get_pauseEntity>
		<set_pauseEntity set="method" line="367"><f a="p_value">
	<c path="awe6.interfaces.IEntity"/>
	<c path="awe6.interfaces.IEntity"/>
</f></set_pauseEntity>
		<new public="1" set="method" line="74"><f a="p_kernel:?p_buttonWidth:?p_buttonHeight:?p_border:?p_backUp:?p_backOver:?p_muteUp:?p_muteOver:?p_unmuteUp:?p_unmuteOver:?p_pauseUp:?p_pauseOver:?p_unpauseUp:?p_unpauseOver:?p_pauseBlur:?p_pauseColor:?p_pauseAlpha">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<c path="awe6.interfaces.IView"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Overlay class provides a minimalist implementation of the IOverlay interface.
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IProgress" params="" file="../../lib/awe6/interfaces/IProgress.hx" interface="1">
		<get_progress public="1" set="method">
			<f a=""><x path="Float"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_progress>
		<progress public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Range: 0...1.  0 represents just starting, 1 represents complete.</haxe_doc>
		</progress>
		<haxe_doc>* The IProgress interface should be implemented by objects intended to progress from start to finish ( 0...1 ).
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IPreloader" params="" file="../../lib/awe6/interfaces/IPreloader.hx" interface="1">
		<extends path="awe6.interfaces.IProgress"/>
		<extends path="awe6.interfaces.IViewable"/>
		<extends path="awe6.interfaces.IProcess"/>
		<haxe_doc>* The IPreloader interface should be implemented by objects intended to act as preloaders.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.drivers.APreloader" params="" file="../../lib/awe6/core/drivers/APreloader.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IPreloader"/>
		<view public="1" get="accessor" set="null"><c path="awe6.interfaces.IView"/></view>
		<progress public="1" get="accessor" set="null"><x path="Float"/></progress>
		<_assets><c path="Array"><c path="String"/></c></_assets>
		<_isDecached><x path="Bool"/></_isDecached>
		<_encrypter><c path="awe6.interfaces.IEncrypter"/></_encrypter>
		<_currentProgress><x path="Float"/></_currentProgress>
		<_currentAsset><x path="Int"/></_currentAsset>
		<_isComplete><x path="Bool"/></_isComplete>
		<_init set="method" line="64" override="1"><f a=""><x path="Void"/></f></_init>
		<_next set="method" line="82">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</_next>
		<_driverLoad set="method" line="105"><f a="p_url">
	<c path="String"/>
	<x path="Void"/>
</f></_driverLoad>
		<_updater set="method" line="110" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="120" override="1"><f a=""><x path="Void"/></f></_disposer>
		<_driverDisposer set="method" line="127"><f a=""><x path="Void"/></f></_driverDisposer>
		<get_view set="method" line="132"><f a=""><c path="awe6.interfaces.IView"/></f></get_view>
		<get_progress set="method" line="137"><f a=""><x path="Float"/></f></get_progress>
		<new public="1" set="method" line="57"><f a="p_kernel:p_assets:?p_isDecached">
	<c path="awe6.interfaces.IKernel"/>
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The APreloader class provides a minimalist abstract implementation of the IPreloader interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.core.drivers.AProfiler" params="" file="../../lib/awe6/core/drivers/AProfiler.hx">
		<extends path="awe6.core.Entity"/>
		<_marginHeight><x path="Int"/></_marginHeight>
		<_marginColor><x path="Int"/></_marginColor>
		<_backgroundColor><x path="Int"/></_backgroundColor>
		<_fpsColor><x path="Int"/></_fpsColor>
		<_memoryColor><x path="Int"/></_memoryColor>
		<_fpsLabel><c path="String"/></_fpsLabel>
		<_memoryLabel><c path="String"/></_memoryLabel>
		<_context><t path="awe6.core.Context"/></_context>
		<_agePrev><x path="Int"/></_agePrev>
		<_width><x path="Int"/></_width>
		<_height><x path="Int"/></_height>
		<_init set="method" line="61" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="76" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_driverUpdate set="method" line="87"><f a=""><x path="Void"/></f></_driverUpdate>
		<new public="1" set="method" line="55"><f a="p_kernel">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The AProfiler class provides debug information.  Based on net.hires.utils.Stats by Mr.doob & Theo v1.3.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.ISceneTransition" params="" file="../../lib/awe6/interfaces/ISceneTransition.hx" interface="1">
		<extends path="awe6.interfaces.IViewable"/>
		<extends path="awe6.interfaces.IProgress"/>
		<extends path="awe6.interfaces.IProcess"/>
		<getDuration public="1" set="method">
			<f a="?asTime">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The time over which the transition occurs.
	 * @param	?asTime	If true returns duration in milliseconds, else updates.
	 * @return	The time over which the transition occurs.</haxe_doc>
		</getDuration>
		<haxe_doc>* The ISceneTransition interface should be implemented by objects intended to display visual transitions during scene changes.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.drivers.ASceneTransition" params="" file="../../lib/awe6/core/drivers/ASceneTransition.hx">
		<extends path="awe6.core.Entity"/>
		<implements path="awe6.interfaces.ISceneTransition"/>
		<progress public="1" get="accessor" set="null"><x path="Float"/></progress>
		<_duration><x path="Int"/></_duration>
		<_context><t path="awe6.core.Context"/></_context>
		<_init set="method" line="56" override="1"><f a=""><x path="Void"/></f></_init>
		<_updater set="method" line="61" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<getDuration public="1" set="method" line="70"><f a="?p_asTime">
	<x path="Bool"/>
	<x path="Int"/>
</f></getDuration>
		<get_progress set="method" line="75"><f a=""><x path="Float"/></f></get_progress>
		<new public="1" set="method" line="49"><f a="p_kernel:?p_duration">
	<c path="awe6.interfaces.IKernel"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The ASceneTransition class provides a minimalist implementation of the ISceneTransition interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.ISession" params="" file="../../lib/awe6/interfaces/ISession.hx" interface="1">
		<get_isTester public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_isTester>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier of this session.</haxe_doc>
		</id>
		<isTester public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Useful for testing and debug.</haxe_doc>
		</isTester>
		<clone public="1" set="method">
			<f a="newId">
				<c path="String"/>
				<c path="awe6.interfaces.ISession"/>
			</f>
			<haxe_doc>* Creates a copy of the current session.
	 * @param	newId	The unique identifier of the copy.
	 * @return	A copy of the current session.</haxe_doc>
		</clone>
		<reset public="1" set="method">
			<f a="?isSaved">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reverts the session back to factory settings (as if created afresh).
	 * @param	?isSaved	If true immediately writes the reset session to disk.</haxe_doc>
		</reset>
		<save public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Writes the session to disk.</haxe_doc>
		</save>
		<delete public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the session from disk.</haxe_doc>
		</delete>
		<getPercentageComplete public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Helper function to calculate overall progress of a game / rewards acquired etc. 
	 * @return	Range 0...1: with 1 representing complete.</haxe_doc>
		</getPercentageComplete>
		<getSessionIds public="1" set="method">
			<f a="?suggestions">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>* Retrieve the collection of sessions identifiers currently saved to disk.
	 * @param	?suggestions	Prepopulates results with the suggestions.
	 * @return	A collection of sessions identifiers currently save to disk.</haxe_doc>
		</getSessionIds>
		<getSessions public="1" set="method">
			<f a="?suggestions">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="awe6.interfaces.ISession"/></c>
			</f>
			<haxe_doc>* Retrieve the collection of sessions currently saved to disk.
	 * @param	?suggestions	Prepopulates results with the suggestions.
	 * @return	A collection of sessions currently save to disk.</haxe_doc>
		</getSessions>
		<deleteAllSessions public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all session data from disk.</haxe_doc>
		</deleteAllSessions>
		<haxe_doc><![CDATA[* The ISession interface should be implemented by objects wishing to preserve interactive information interchange.
 * <p>The session can be used as both memento and arbitrator between subsystems - including entities and scenes.</p>
 * <p>Sessions can be permanently stored and retrieved on future application ezecution.</p>
 * @author	Robert Fell]]></haxe_doc>
	</class>
	<class path="awe6.core.drivers.ASession" params="" file="../../lib/awe6/core/drivers/ASession.hx">
		<implements path="awe6.interfaces.ISession"/>
		<DEBUG_ID public="1" get="inline" set="null" line="43" static="1"><c path="String"/></DEBUG_ID>
		<_VERSION_ID get="inline" set="null" line="44" static="1"><c path="String"/></_VERSION_ID>
		<_kernel><c path="awe6.interfaces.IKernel"/></_kernel>
		<_tools><c path="awe6.interfaces.ITools"/></_tools>
		<_data><d/></_data>
		<_savedData><d/></_savedData>
		<_version><x path="Int"/></_version>
		<id public="1" set="null"><c path="String"/></id>
		<isTester public="1" get="accessor" set="null"><x path="Bool"/></isTester>
		<loadCount public="1"><x path="Int"/></loadCount>
		<saveCount public="1"><x path="Int"/></saveCount>
		<_init set="method" line="71"><f a=""><x path="Void"/></f></_init>
		<_driverLoad set="method" line="89"><f a=""><x path="Void"/></f></_driverLoad>
		<_driverSave set="method" line="95"><f a=""><x path="Void"/></f></_driverSave>
		<_driverReset set="method" line="101"><f a=""><x path="Void"/></f></_driverReset>
		<_getter set="method" line="107"><f a=""><x path="Void"/></f></_getter>
		<_setter set="method" line="115"><f a=""><x path="Void"/></f></_setter>
		<_resetter set="method" line="123"><f a=""><x path="Void"/></f></_resetter>
		<clone public="1" get="inline" set="null" line="131"><f a="p_newId">
	<c path="String"/>
	<c path="awe6.interfaces.ISession"/>
</f></clone>
		<reset public="1" get="inline" set="null" line="138"><f a="?p_isSaved">
	<x path="Bool"/>
	<x path="Void"/>
</f></reset>
		<delete public="1" get="inline" set="null" line="149"><f a=""><x path="Void"/></f></delete>
		<save public="1" get="inline" set="null" line="154"><f a=""><x path="Void"/></f></save>
		<getPercentageComplete public="1" set="method" line="163"><f a=""><x path="Float"/></f></getPercentageComplete>
		<getSessionIds public="1" set="method" line="169"><f a="?p_suggestions">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></getSessionIds>
		<getSessions public="1" set="method" line="190"><f a="?p_suggestions">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="awe6.interfaces.ISession"/></c>
</f></getSessions>
		<deleteAllSessions public="1" set="method" line="201"><f a=""><x path="Void"/></f></deleteAllSessions>
		<toString public="1" set="method" line="206"><f a=""><c path="String"/></f></toString>
		<get_isTester set="method" line="211"><f a=""><x path="Bool"/></f></get_isTester>
		<new public="1" set="method" line="58"><f a="p_kernel:?p_id">
	<c path="awe6.interfaces.IKernel"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The ASession class provides a minimalist abstract implementation of the ISession interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="awe6.interfaces.IPriority" params="" file="../../lib/awe6/interfaces/IPriority.hx" interface="1">
		<get_priority public="1" set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_priority>
		<set_priority public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_priority>
		<priority public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The rank score of this item.
	 * <p>Higher numbers should be considered on top of the list, therefore of higher priority.</p>]]></haxe_doc>
		</priority>
		<haxe_doc>* The IPriority interface should be implemented by objects intended to be ranked or sorted.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.interfaces.IView" params="" file="../../lib/awe6/interfaces/IView.hx" interface="1">
		<extends path="awe6.interfaces.IUpdateable"/>
		<extends path="awe6.interfaces.IDisposable"/>
		<extends path="awe6.interfaces.IPositionable"/>
		<extends path="awe6.interfaces.IPriority"/>
		<get_parent public="1" set="method">
			<f a=""><c path="awe6.interfaces.IView"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_parent>
		<set_isVisible public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_isVisible>
		<get_isInViewStack public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_isInViewStack>
		<owner public="1" set="null">
			<d/>
			<haxe_doc>* Optional: the object who this view represents.</haxe_doc>
		</owner>
		<parent public="1" get="accessor" set="null">
			<c path="awe6.interfaces.IView"/>
			<haxe_doc><![CDATA[* The parent view of this view.
	 * <p>The reference is null if this view has no parent (for exemple a view not in the view traversal stack).</p>]]></haxe_doc>
		</parent>
		<isVisible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specify the visibility of this view.
	 * <p>If true the view will be displayed, if false the view is hidden.</p>]]></haxe_doc>
		</isVisible>
		<isInViewStack public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Determined by whether this view is visible and included in a visible branch of the view stack (i.e. actually has the potential to be drawn within the overlay).
	 * <p>If true the view is potentially visible, if false the view is impossible to be seen.</p>]]></haxe_doc>
		</isInViewStack>
		<globalX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal position considering all parent's positions / scene graph.</haxe_doc>
		</globalX>
		<globalY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical position considering all parent's positions / scene graph.</haxe_doc>
		</globalY>
		<addChild public="1" set="method">
			<f a="child:?priority">
				<c path="awe6.interfaces.IView"/>
				<x path="Int"/>
				<c path="awe6.interfaces.IView"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new view child to this view. 
	 * <p>A view can have multiple children, and when you add a child to a view, it is automatically connected to the parent node through its parent property.</p>
	 * @param	child	The child view to add.
	 * @param	?priority	The sorting priority of the child view to add.  Higher numbers will appear towards the top of the view stack.  Default value is 0.
	 * @return	Added view (to allow decoration).  Or null if addition was unsuccessful.]]></haxe_doc>
		</addChild>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="awe6.interfaces.IView"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove the specified view.
	 * <p>The removed view will no longer be included in the view traversal stack so will no longer be visible.</p>
	 * <p>The view itself is still in memory, if you want to free them completely call child.dispose().</p>
	 * @param	child	The view to remove.]]></haxe_doc>
		</removeChild>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Removes all child views.
	 * <p>The children are still in memory, if you want to free them completely call view.dispose() from their owner object.</p>]]></haxe_doc>
		</clear>
		<remove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Removes this view from the view traversal stack and subsequently all of its child views.
	 * <p>The view itself is still in memory, if you want to free it completely call dispose().</p>]]></haxe_doc>
		</remove>
		<haxe_doc>* The IView interface should be implemented by all objects in the view broad phase traversal stack.
 * @author	Robert Fell</haxe_doc>
	</class>
	<class path="awe6.core.drivers.AView" params="" file="../../lib/awe6/core/drivers/AView.hx">
		<extends path="awe6.core.Process"/>
		<implements path="awe6.interfaces.IView"/>
		<context public="1" set="null"><t path="awe6.core.Context"/></context>
		<owner public="1" set="null"><d/></owner>
		<globalX public="1" set="null"><x path="Float"/></globalX>
		<globalY public="1" set="null"><x path="Float"/></globalY>
		<priority public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</priority>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<isVisible public="1" set="accessor"><x path="Bool"/></isVisible>
		<isInViewStack public="1" get="accessor" set="null"><x path="Bool"/></isInViewStack>
		<parent public="1" get="accessor" set="null"><c path="awe6.interfaces.IView"/></parent>
		<_isDirty><x path="Bool"/></_isDirty>
		<_children><c path="Array"><c path="awe6.core.drivers.AView"/></c></_children>
		<_init set="method" line="66" override="1"><f a=""><x path="Void"/></f></_init>
		<addChild public="1" set="method" line="78"><f a="p_child:?p_priority">
	<c path="awe6.interfaces.IView"/>
	<x path="Int"/>
	<c path="awe6.interfaces.IView"/>
</f></addChild>
		<removeChild public="1" set="method" line="102"><f a="p_child">
	<c path="awe6.interfaces.IView"/>
	<x path="Void"/>
</f></removeChild>
		<remove public="1" set="method" line="121"><f a=""><x path="Void"/></f></remove>
		<clear public="1" set="method" line="129"><f a=""><x path="Void"/></f></clear>
		<_updater set="method" line="137" override="1"><f a="?p_deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></_updater>
		<_disposer set="method" line="153" override="1"><f a=""><x path="Void"/></f></_disposer>
		<_driverDisposer set="method" line="161"><f a=""><x path="Void"/></f></_driverDisposer>
		<_draw set="method" line="166"><f a=""><x path="Void"/></f></_draw>
		<_driverDraw set="method" line="177"><f a=""><x path="Void"/></f></_driverDraw>
		<_setParent set="method" line="182"><f a="p_parent">
	<c path="awe6.interfaces.IView"/>
	<x path="Void"/>
</f></_setParent>
		<get_priority set="method" line="187"><f a=""><x path="Int"/></f></get_priority>
		<set_priority set="method" line="192"><f a="p_value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_priority>
		<set_isVisible set="method" line="210"><f a="p_value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isVisible>
		<get_parent set="method" line="228"><f a=""><c path="awe6.interfaces.IView"/></f></get_parent>
		<get_isInViewStack set="method" line="233"><f a=""><x path="Bool"/></f></get_isInViewStack>
		<set_x set="method" line="250"><f a="p_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="257"><f a="p_value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<setPosition public="1" set="method" line="264"><f a="p_x:p_y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<new public="1" set="method" line="58"><f a="p_kernel:?p_context:?p_priority:?p_owner">
	<c path="awe6.interfaces.IKernel"/>
	<t path="awe6.core.Context"/>
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The View class provides a minimalist implementation of the IView interface.
 * <p>It is intended as an abstract class to be extended by target specific drivers.</p>
 * <p>For API documentation please review the corresponding Interfaces.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="awe6.interfaces.EAgenda" params="" file="../../lib/awe6/interfaces/EAgenda.hx">
		<ALWAYS><haxe_doc>* The default EAgenda.  Anything assigned to this will be run each update irrespective of what agenda the parent is assigned.</haxe_doc></ALWAYS>
		<BIRTH/>
		<DEATH/>
		<STANDARD/>
		<ATTACK/>
		<DEFEND/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EAgenda to be extended (e.g. for using entity specific enumerated agendas).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc><![CDATA[* Can be used to influence the internal state of an IEntity via IAgendaManager.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EAudioChannel" params="" file="../../lib/awe6/interfaces/EAudioChannel.hx">
		<DEFAULT/>
		<EFFECTS/>
		<INTERFACE/>
		<MUSIC/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EAudioChannel to be extended (e.g. for using project specific enumerated audio channels or entity specific channels).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc><![CDATA[* Can be used to separate audio space to allow different transforms to apply to different groups of playing sounds.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EFullScreen" params="" file="../../lib/awe6/interfaces/EFullScreen.hx">
		<DISABLED><haxe_doc>* FullScreen mode is not available.</haxe_doc></DISABLED>
		<NO_SCALE><haxe_doc>* Preserves original pixel size.</haxe_doc></NO_SCALE>
		<SCALE_ASPECT_RATIO_IGNORE><haxe_doc>* Scale without preserving aspect ratio - some distortion may occur, including non linear pixel sizes.</haxe_doc></SCALE_ASPECT_RATIO_IGNORE>
		<SCALE_ASPECT_RATIO_PRESERVE><haxe_doc>* Scale without aspect ratio distortion.  Non linear pixel sizes may occur.</haxe_doc></SCALE_ASPECT_RATIO_PRESERVE>
		<SCALE_NEAREST_MULTIPLE><haxe_doc>* Scale without distortion, and doubling pixels (2x2, 4x4 etc) to nearest multiple to preserve pixel sizes.</haxe_doc></SCALE_NEAREST_MULTIPLE>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EScale to be extended (e.g. for using project specific scale modes).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc><![CDATA[* Representing possible full screen modes.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EJoypadButton" params="" file="../../lib/awe6/interfaces/EJoypadButton.hx">
		<FIRE/>
		<UP/>
		<RIGHT/>
		<DOWN/>
		<LEFT/>
		<PRIMARY/>
		<SECONDARY/>
		<haxe_doc><![CDATA[* Representing the buttons on a Joypad for use in the IJoypad virtual controller.
 * <p>Includes directional buttons and two fire buttons: Primary & Secondary. Fire is used as a shortcut for Primary or Secondary.</p>
 * @author	Robert Fell]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="awe6.interfaces.EJoypadTouch" params="" file="../../lib/awe6/interfaces/EJoypadTouch.hx">
		<DISABLED><haxe_doc><![CDATA[* Touch input is disabled for joypad.  The default.
	 * <p>It is advised that EJoypadTouch be set in Factory based on device interrogation.</p>]]></haxe_doc></DISABLED>
		<DPAD><haxe_doc><![CDATA[* The screen is split into five fixed position regions corresponding to directions, only one can be down at a time.
	 * <p>A single fire button (primary) is located in the center.</p>]]></haxe_doc></DPAD>
		<JOYSTICK a="?distance">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A self centering joystick represented by a constant drag / touch.  A drag can begin anywhere.
	 * <p>Distance sets the minimum vector length that determines movement.  20 pixels is the default.</p>
	 * <p>If the horizontal drag vector is > distance then left or right is down.</p>
	 * <p>If the vertical drag vector is > distance then up or down is down.</p>
	 * <p>Any tap of less than 200ms triggers primary down.</p>]]></haxe_doc>
		</JOYSTICK>
		<SWIPE a="?speed">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A swipe can begin anywhere.  Speed sets the minimum vector length (pixels per second) that determines movement.  100 pixels is the default.
	 * <p>If the horizontal swipe vector is > speed then left or right is down.</p>
	 * <p>If the vertical swipe vector is > speed then up or down is down.</p>
	 * <p>Any tap of less than 200ms triggers primary down.</p>]]></haxe_doc>
		</SWIPE>
		<haxe_doc>* Representing the touch input modes for a Touchscreen Joypad for use in the IJoypad virtual controller.
 * @author	Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EKey" params="" file="../../lib/awe6/interfaces/EKey.hx">
		<NUM_LOCK/>
		<CLEAR/>
		<HELP/>
		<ALT/>
		<BACKSPACE/>
		<CAPS_LOCK/>
		<CONTROL/>
		<DELETE/>
		<DOWN/>
		<END/>
		<ENTER/>
		<ESCAPE/>
		<F1/>
		<F10/>
		<F11/>
		<F12/>
		<F13/>
		<F14/>
		<F15/>
		<F2/>
		<F3/>
		<F4/>
		<F5/>
		<F6/>
		<F7/>
		<F8/>
		<F9/>
		<HOME/>
		<INSERT/>
		<LEFT/>
		<NUMPAD_0/>
		<NUMPAD_1/>
		<NUMPAD_2/>
		<NUMPAD_3/>
		<NUMPAD_4/>
		<NUMPAD_5/>
		<NUMPAD_6/>
		<NUMPAD_7/>
		<NUMPAD_8/>
		<NUMPAD_9/>
		<NUMPAD_ADD/>
		<NUMPAD_DECIMAL/>
		<NUMPAD_DIVIDE/>
		<NUMPAD_ENTER/>
		<NUMPAD_MULTIPLY/>
		<NUMPAD_SUBTRACT/>
		<PAGE_DOWN/>
		<PAGE_UP/>
		<RIGHT/>
		<SHIFT/>
		<SPACE/>
		<TAB/>
		<UP/>
		<A/>
		<B/>
		<C/>
		<D/>
		<E/>
		<F/>
		<G/>
		<H/>
		<I/>
		<J/>
		<K/>
		<L/>
		<M/>
		<N/>
		<O/>
		<P/>
		<Q/>
		<R/>
		<S/>
		<T/>
		<U/>
		<V/>
		<W/>
		<X/>
		<Y/>
		<Z/>
		<NUMBER_0/>
		<NUMBER_1/>
		<NUMBER_2/>
		<NUMBER_3/>
		<NUMBER_4/>
		<NUMBER_5/>
		<NUMBER_6/>
		<NUMBER_7/>
		<NUMBER_8/>
		<NUMBER_9/>
		<COLON/>
		<EQUALS/>
		<HYPHEN/>
		<SLASH/>
		<TILDE/>
		<SQUARELEFT/>
		<SQUARERIGHT/>
		<BACKSLASH/>
		<APOSTROPHE/>
		<TOPLEFT/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EKey to be extended (e.g. for using non US / English keyboards).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc><![CDATA[* Representing the keys on a Keyboard for use in the IInputKeyboard virtual controller.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EMessage" params="" file="../../lib/awe6/interfaces/EMessage.hx">
		<DISPOSE/>
		<INIT/>
		<PAUSE/>
		<RESUME/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EMessage to be extended (e.g. for using project specific mesages).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc>* These messages are dispatched internally.
 * @author	Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EMouseButton" params="" file="../../lib/awe6/interfaces/EMouseButton.hx">
		<LEFT/>
		<MIDDLE/>
		<RIGHT/>
		<haxe_doc>* Representing the buttons on a Mouse for use in the IInputMouse virtual controller.
 * @author	Robert Fell</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="awe6.interfaces.EMouseCursor" params="" file="../../lib/awe6/interfaces/EMouseCursor.hx">
		<ARROW/>
		<AUTO/>
		<BUTTON/>
		<HAND/>
		<IBEAM/>
		<SUB_TYPE a="value"><d/></SUB_TYPE>
		<haxe_doc>* Representing the mouse cursor for use in the IInputMouse virtual controller.
 * @author	Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EOverlayButton" params="" file="../../lib/awe6/interfaces/EOverlayButton.hx">
		<BACK/>
		<MUTE/>
		<UNMUTE/>
		<PAUSE/>
		<UNPAUSE/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EOverlayButton to be extended (e.g. for using project specific overlay buttons - settings, restart, context help).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc>* Representing the control buttons on the IOverlay.
 * @author	Robert Fell</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.EScene" params="" file="../../lib/awe6/interfaces/EScene.hx">
		<SPLASH/>
		<INTRO/>
		<SELECT_SESSION/>
		<SELECT_STORY/>
		<SELECT_LEVEL/>
		<INSTRUCTIONS/>
		<SETTINGS/>
		<MENU/>
		<AVATAR/>
		<SHOP/>
		<REWARDS/>
		<LEADERBOARD/>
		<GAME/>
		<INTERSTITIAL/>
		<CINEMATIC/>
		<RESULTS/>
		<EXIT/>
		<TEST><haxe_doc>* Recommended to be used as a testing sandbox to test new entities etc.</haxe_doc></TEST>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows EScene to be extended (e.g. for using project specific enumerated scene types).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc><![CDATA[* Default Scene types.  A basic game can be made using these defaults.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="awe6.interfaces.ETextAlign" params="" file="../../lib/awe6/interfaces/ETextAlign.hx">
		<JUSTIFY/>
		<LEFT/>
		<CENTER/>
		<RIGHT/>
		<haxe_doc>* Representing alternative horizontal text alignments for ITextStyle implementations.
 * @author	Robert Fell</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="awe6.interfaces.ETextStyle" params="" file="../../lib/awe6/interfaces/ETextStyle.hx">
		<BUTTON/>
		<BODY/>
		<HEADLINE/>
		<SUBHEAD/>
		<SMALLPRINT/>
		<OVERSIZED/>
		<SUB_TYPE a="value">
			<d/>
			<haxe_doc>* Allows ETextStyle to be extended (e.g. for using project specific text styles).</haxe_doc>
		</SUB_TYPE>
		<haxe_doc><![CDATA[* Representing default identifiers of ITextStyles.
 * <p>Can be extended with SubType by using concrete project values.</p> 
 * @author	Robert Fell]]></haxe_doc>
	</enum>
	<abstract path="haxe.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which
		* is public and
		* unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe._EntryPoint.Lock" params="" file="C:\HaxeToolkit\haxe\std/haxe/EntryPoint.hx" private="1" module="haxe.EntryPoint">
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._EntryPoint.Mutex" params="" file="C:\HaxeToolkit\haxe\std/haxe/EntryPoint.hx" private="1" module="haxe.EntryPoint">
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.EntryPoint" params="" file="C:\HaxeToolkit\haxe\std/haxe/EntryPoint.hx">
		<sleepLock line="46" static="1"><c path="haxe._EntryPoint.Lock"/></sleepLock>
		<mutex line="47" static="1"><c path="haxe._EntryPoint.Mutex"/></mutex>
		<pending line="49" static="1"><c path="Array"><f a=""><x path="Void"/></f></c></pending>
		<threadCount public="1" set="null" line="51" static="1"><x path="Int"/></threadCount>
		<processEvents set="method" line="91" static="1"><f a=""><x path="Float"/></f></processEvents>
		<run public="1" set="method" line="112" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If haxe.MainLoop is kept from DCE, then we will insert an haxe.EntryPoint.run() call just at then end of main().
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="C:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="47" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="C:\HaxeToolkit\haxe\std/haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<delay public="1" set="method" line="22">
			<f a="t">
				<t path="Null"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Delay the execution of the event for the given time, in seconds.
		If t is null, the event will be run at tick() time.</haxe_doc>
		</delay>
		<stop public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the event from firing anymore.</haxe_doc>
		</stop>
		<new set="method" line="12"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainLoop" params="" file="C:\HaxeToolkit\haxe\std/haxe/MainLoop.hx">
		<pending line="53" static="1"><c path="haxe.MainEvent"/></pending>
		<threadCount public="1" get="null" set="null" static="1"><x path="Int"/></threadCount>
		<add public="1" set="method" line="74" static="1">
			<f a="f:?priority">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.MainEvent"/>
			</f>
			<haxe_doc>Add a pending event to be run into the main loop.</haxe_doc>
		</add>
		<sortEvents set="method" line="85" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="146" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<BASE64_CODES line="70" static="1"><x path="haxe.ds.Vector"><t path="Null"><x path="Int"/></t></x></BASE64_CODES>
		<run public="1" set="method" line="556" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="116">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="153"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="172"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="209"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="227">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Timer.hx">
		<delay public="1" set="method" line="136" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>Invokes `f` after `time_ms` milliseconds.

		This is a convenience function for creating a new Timer instance with
		`time_ms` as argument, binding its run() method to `f` and then stopping
		`this` Timer upon the first invocation.

		If `f` is null, the result is unspecified.</haxe_doc>
		</delay>
		<event><c path="haxe.MainEvent"/></event>
		<stop public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:
			var timer = new haxe.Timer(1000); // 1000ms delay
			timer.run = function() { ... }

		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="60">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="C:\HaxeToolkit\haxe\std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="477">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="478">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveEnum>
		<new public="1" set="method" line="476"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="63" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`. 
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="65" static="1"><c path="String"/></BASE64>
		<CODES line="68" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="70" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="465" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="172"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="186"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="201"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="233">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="102">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericCell" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/GenericStack.hx" module="haxe.ds.GenericStack">
		<elt public="1"><c path="haxe.ds.GenericCell.T"/></elt>
		<next public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c></next>
		<new public="1" set="method" line="35"><f a="elt:next">
	<c path="haxe.ds.GenericCell.T"/>
	<c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericCell.T"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A cell of `haxe.ds.GenericStack`.
  
	@see https://haxe.org/manual/std-GenericStack.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.GenericStack" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/GenericStack.hx">
		<head public="1"><c path="haxe.ds.GenericCell"><c path="haxe.ds.GenericStack.T"/></c></head>
		<remove public="1" set="method" line="124">
			<f a="v">
				<c path="haxe.ds.GenericStack.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first element which is equal to `v` according to the `==`
		operator.

		This method traverses the stack until it finds a matching element and
		unlinks it, returning true.

		If no matching element is found, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="155">
			<f a=""><t path="Iterator"><c path="haxe.ds.GenericStack.T"/></t></f>
			<haxe_doc>Returns an iterator over the elements of `this` GenericStack.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="74">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty GenericStack.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[A stack of elements.

	This class is generic, which means one type is generated for each type
	parameter T on static targets. For example:

	- `new GenericStack<Int>()` generates `GenericStack_Int`
	- `new GenericStack<String>()` generates `GenericStack_String`

	The generated name is an implementation detail and should not be relied
	upon.

	@see https://haxe.org/manual/std-GenericStack.html]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="462" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Eof" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.xml._Parser.S" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" expr="0" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" expr="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" expr="2" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" expr="3" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TAG_NAME>
		<BODY public="1" get="inline" set="null" expr="4" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" expr="5" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" expr="6" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" expr="7" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" expr="8" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" expr="9" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</CHILDS>
		<CLOSE public="1" get="inline" set="null" expr="10" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</CLOSE>
		<WAIT_END public="1" get="inline" set="null" expr="11" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" expr="12" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" expr="13" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</PCDATA>
		<HEADER public="1" get="inline" set="null" expr="14" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</HEADER>
		<COMMENT public="1" get="inline" set="null" expr="15" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</COMMENT>
		<DOCTYPE public="1" get="inline" set="null" expr="16" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOCTYPE>
		<CDATA public="1" get="inline" set="null" expr="17" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CDATA>
		<ESCAPE public="1" get="inline" set="null" expr="18" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</ESCAPE>
	</class>
	<class path="haxe.xml.XmlParserException" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>* the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>* the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>* the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>* the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>* the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="96"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="76"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx">
		<escapes line="104" static="1"><c path="haxe.ds.StringMap"><c path="String"/></c></escapes>
		<parse public="1" set="method" line="119" static="1">
			<f a="str:?strict">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>* Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.
	 *
	 * @throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="126" static="1"><f a="str:strict:?p:?parent">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="Xml"/>
	<x path="Int"/>
</f></doParse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="C:\HaxeToolkit\haxe\std/haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert `Xml` to string representation.
		
		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to 
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
</haxe>